<!DOCTYPE html>
<html lang="ko">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <title>마이티 - 테스트 버전</title>
    <style>
        /* ===== Premium Theme & Reset ===== */
        :root {
            --primary-color: #4CAF50;
            --primary-dark: #388E3C;
            --secondary-color: #FFD700;
            --accent-color: #FF5252;
            --bg-gradient: radial-gradient(circle at center, #1b5e20 0%, #0d2e12 100%);
            --glass-bg: rgba(20, 20, 20, 0.6);
            --glass-border: 1px solid rgba(255, 255, 255, 0.1);
            --card-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
            --card-hover-shadow: 0 8px 16px rgba(0, 0, 0, 0.4);
            --text-color: #e0e0e0;
            --font-main: 'Segoe UI', 'Roboto', 'Helvetica Neue', sans-serif;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            user-select: none;
            /* Prevent text selection for game feel */
        }

        body {
            font-family: var(--font-main);
            background: var(--bg-gradient);
            min-height: 100vh;
            color: var(--text-color);
            overflow: auto;
        }

body.mobile-mode {
    overflow: hidden;
}


        #app {
            display: flex;
            flex-direction: column;
        }


        /* ===== 상단 정보 바 ===== */
        #info-bar {
            background: rgba(0, 0, 0, 0.5);
            padding: 5px 15px;
            border-radius: 8px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 5px;
        }


        .game-info {
            display: flex;
            gap: 20px;
            flex-wrap: wrap;
        }

        .game-info span {
            background: rgba(255, 255, 255, 0.1);
            padding: 5px 12px;
            border-radius: 5px;
            font-size: 14px;
        }

        .controls {
            display: flex;
            gap: 10px;
        }

        .controls button {
            padding: 6px 10px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 11px;
            white-space: nowrap;
            transition: all 0.2s;
        }


        #test-mode-toggle {
            background: #4CAF50;
            color: white;
        }

        #test-mode-toggle.active {
            background: #4CAF50;
        }

        #test-mode-toggle:not(.active) {
            background: #666;
        }

        #settings-btn {
            background: #2196F3;
            color: white;
        }

        .controls button:hover {
            transform: scale(1.05);
        }

        /* ===== 메인 게임 영역 ===== */
        #game-area {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 3px;
        }

        /* ===== 플레이어 영역 ===== */
        .player-area {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 6px;
            padding: 4px 8px;
            transition: all 0.3s;
        }


        .player-area.active-turn {
            box-shadow: 0 0 20px rgba(255, 215, 0, 0.7);
            border: 2px solid gold;
        }

        .player-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 2px;
            padding-bottom: 2px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.2);
        }


        .player-name {
            font-weight: bold;
            font-size: 13px;
        }


        .player-role {
            font-size: 12px;
            padding: 2px 8px;
            border-radius: 3px;
        }

        .player-role.master {
            background: #FFD700;
            color: #000;
        }

        .player-role.friend {
            background: #FF69B4;
            color: #000;
        }

        .player-role.opposition {
            background: #666;
            color: #fff;
        }

        .player-hand {
            display: flex;
            flex-wrap: nowrap;
            min-height: 120px;
            justify-content: center;
            padding-left: 15px;
        }


        .player-hand .card {
            margin-left: -30px;
        }

        .player-hand .card:first-child {
            margin-left: 0;
        }

        .player-hand .card:hover {
            z-index: 10;
        }

        .player-hand .card.playable:hover {
            transform: translateY(-15px);
            z-index: 20;
        }

        .player-score {
            margin-top: 2px;
            font-size: 12px;
            text-align: center;
        }


        .top-row {
            display: flex;
            justify-content: center;
            gap: 20px;
        }

        .player-area.top-left,
        .player-area.top-right {
            width: 520px;
        }

        .player-area.top-left .player-hand .card,
        .player-area.top-right .player-hand .card {
            margin-left: -45px;
        }


        .player-area.top-left .player-hand .card:first-child,
        .player-area.top-right .player-hand .card:first-child {
            margin-left: 0;
        }

        .middle-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex: 1;
        }

        .player-area.left,
        .player-area.right {
            width: 520px;
            padding: 4px 8px;
        }

        .player-area.left .player-hand,
        .player-area.right .player-hand {
            min-height: 120px;
            padding-left: 15px;
        }

        .player-area.left .player-hand .card,
        .player-area.right .player-hand .card {
            margin-left: -45px;
        }

        .player-area.left .player-hand .card:first-child,
        .player-area.right .player-hand .card:first-child {
            margin-left: 0;
        }

        .player-area.left .player-score,
        .player-area.right .player-score {
            margin-top: 2px;
            font-size: 11px;
        }

        .bottom-row {
            display: flex;
            justify-content: center;
            gap: 20px;
        }

        .player-area.bottom-left {
            width: 250px;
        }

        .player-area.user {
            width: 1000px;
            padding: 3px 8px;
        }

        .player-area.user .player-hand {
            min-height: 120px;
            padding-left: 10px;
        }

        .player-area.user .player-hand .card {
            margin-left: 0;
        }

        .player-area.user .player-hand .card:first-child {
            margin-left: 0;
        }

        /* ===== 카드 스타일 ===== */
        .card {
            width: 86px;
            height: 116px;
            border-radius: 4px;
            cursor: default;
            transition: all 0.2s;
            position: relative;
            box-shadow: none;
            overflow: hidden;
            background-color: transparent;
            border: none;
        }


        .card.face-up {
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
        }

        .card.face-down {
            background-image: url('https://deckofcardsapi.com/static/img/back.png');
            background-size: cover;
            background-position: center;
        }

        .card .card-image {
            width: 100%;
            height: 100%;
            object-fit: contain;
            border-radius: 3px;
            border: none;
        }

        .card.joker {
            background-color: transparent;
        }

        .card.joker .joker-image {
            width: 100%;
            height: 100%;
            object-fit: contain;
            border-radius: 4px;
        }

        .card.highlighted {
            box-shadow: 0 0 10px 3px rgba(76, 175, 80, 0.8);
            border-color: #4CAF50;
        }

        .card.dimmed {
            opacity: 0.5;
        }

        .card.selected {
            transform: translateY(-15px);
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.5);
            border-color: #FFD700;
        }

        .card.playable {
            cursor: pointer;
        }

        .card.playable:hover {
            transform: translateY(-10px);
        }

        .player-area.user .card {
            width: 86px;
            height: 116px;
        }


        .player-area.user .player-header {
            margin-bottom: 2px;
            padding-bottom: 2px;
        }

        .player-area.user .player-score {
            margin-top: 2px;
        }

        .card .special-label {
            position: absolute;
            top: -10px;
            right: -10px;
            background: linear-gradient(135deg, #FFD700 0%, #FFA000 100%);
            color: #000;
            font-size: 9px;
            padding: 3px 6px;
            border-radius: 4px;
            font-weight: bold;
            box-shadow: 1px 1px 3px rgba(0, 0, 0, 0.3);
            z-index: 10;
        }

        /* ===== 트릭 영역 ===== */
        #trick-area {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

        .trick-cards {
            position: relative;
            width: 550px;
            height: 350px;
        }


       .trick-card {
    position: absolute;
    width: 86px;
    height: 116px;
    transition: all 0.3s ease;
}

        .trick-card[data-player="0"] {
            bottom: 0;
            left: 50%;
            transform: translateX(-50%);
        }

        .trick-card[data-player="1"] {
            top: 50%;
            left: 0;
            transform: translateY(-50%);
        }

        .trick-card[data-player="2"] {
            top: 0;
            left: 130px;
        }

        .trick-card[data-player="3"] {
            top: 0;
            right: 130px;
        }

        .trick-card[data-player="4"] {
            top: 50%;
            right: 0;
            transform: translateY(-50%);
        }


        .trick-card .card {
            width: 100%;
            height: 100%;
        }

        .trick-card.winner .card {
            box-shadow: 0 0 20px rgba(255, 215, 0, 0.9);
            border-color: #ffd700;
        }

        #trick-info {
            margin-top: 10px;
            text-align: center;
            font-size: 14px;
            background: rgba(0, 0, 0, 0.3);
            padding: 5px 15px;
            border-radius: 5px;
        }

        /* ===== 액션 영역 ===== */
        #action-area {
            background: rgba(0, 0, 0, 0.5);
            padding: 8px;
            border-radius: 8px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            gap: 5px;
            min-height: 40px;
        }


        #action-message {
            color: #FFD700;
            font-size: 16px;
            font-weight: bold;
            text-align: center;
        }

        #action-buttons {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            justify-content: center;
        }

        #action-buttons button {
            padding: 10px 25px;
            font-size: 16px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.2s;
        }

        #action-buttons button.primary {
            background: #4CAF50;
            color: white;
        }

        #action-buttons button.secondary {
            background: #666;
            color: white;
        }

        #action-buttons button:disabled {
            background: #444;
            cursor: not-allowed;
            opacity: 0.5;
        }

        #action-buttons button:not(:disabled):hover {
            transform: scale(1.05);
        }

        #timer {
            font-size: 18px;
            font-weight: bold;
            color: #FFD700;
        }

        /* ===== AI 로그 패널 ===== */
        #ai-log-panel {
            position: fixed;
            top: 60px;
            right: 10px;
            width: 300px;
            max-height: calc(100vh - 80px);
            background: rgba(0, 0, 0, 0.85);
            border-radius: 10px;
            z-index: 100;
            display: flex;
            flex-direction: column;
        }

        #ai-log-panel .panel-header {
            padding: 8px 12px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: pointer;
            border-bottom: 1px solid #444;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 10px 10px 0 0;
            flex-shrink: 0;
        }

        #ai-log-panel .panel-header span {
            font-size: 14px;
            font-weight: bold;
        }

        #ai-log-panel .panel-header button {
            background: none;
            border: none;
            color: white;
            cursor: pointer;
            font-size: 14px;
            padding: 2px 6px;
        }

        #ai-log-panel .panel-content {
            flex: 1;
            overflow-y: auto;
            padding: 12px;
            max-height: 500px;
        }

        #ai-log-panel.collapsed {
            max-height: none;
        }

        #ai-log-panel.collapsed .panel-content {
            display: none;
        }

        .log-entry {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 5px;
            padding: 8px 10px;
            margin-bottom: 8px;
            font-size: 16px;
        }

        .log-entry .log-header {
            font-weight: bold;
            margin-bottom: 4px;
            color: #FFD700;
            font-size: 18px;
        }

        .log-entry .log-reasons {
            color: #bbb;
            padding-left: 8px;
            line-height: 1.4;
            font-size: 14px;
        }

        .log-entry .reason-line {
            margin: 3px 0;
        }

        /* ===== 모달 스타일 ===== */
        .modal {
            position: fixed;
            top: 50%;
            left: calc(50% - 140px);
            transform: translate(-50%, -50%);
            background: #2d2d2d;
            border-radius: 12px;
            padding: 20px;
            z-index: 1000;
            min-width: 350px;
            box-shadow: 0 10px 50px rgba(0, 0, 0, 0.5);
        }

        .modal.hidden {
            display: none;
        }

        .modal h3 {
            margin-bottom: 15px;
            text-align: center;
            font-size: 20px;
        }

        .modal p {
            margin-bottom: 12px;
            text-align: center;
            color: #ccc;
            font-size: 14px;
        }

        #modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            z-index: 999;
        }

        #modal-overlay.hidden {
            display: none;
        }

        /* 비딩 모달 */
        #bidding-modal {
            min-width: 320px;
            max-width: 750px;
            padding: 15px 20px;
            top: 30%;
        }

        #bidding-modal h3 {
            font-size: 18px;
            margin-bottom: 12px;
        }

        .current-bid {
            text-align: center;
            margin-bottom: 12px;
            font-size: 14px;
            color: #FFD700;
            padding: 6px;
            background: rgba(255, 215, 0, 0.1);
            border-radius: 5px;
        }

        .bid-controls {
            margin-bottom: 12px;
        }

        .bid-controls label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
            font-size: 13px;
        }

        .bid-number,
        .bid-suit {
            margin-bottom: 10px;
        }

        .number-buttons,
        .suit-buttons {
            display: flex;
            gap: 4px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .number-buttons button,
        .suit-buttons button {
            padding: 6px 10px;
            font-size: 13px;
            border: 2px solid #444;
            background: #333;
            color: white;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s;
            min-width: 32px;
        }

        .number-buttons button:hover,
        .suit-buttons button:hover {
            background: #444;
        }

        .number-buttons button.selected,
        .suit-buttons button.selected {
            background: #4CAF50;
            border-color: #4CAF50;
        }

        .number-buttons button:disabled,
        .suit-buttons button:disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }

        .suit-buttons button {
            font-size: 20px;
            width: 40px;
            height: 40px;
            padding: 0;
        }

        .suit-buttons button.red {
            color: #d32f2f;
        }

        .bid-preview {
            text-align: center;
            font-size: 16px;
            margin-bottom: 12px;
            color: #4CAF50;
            padding: 6px;
            background: rgba(76, 175, 80, 0.1);
            border-radius: 5px;
        }

        .bid-actions {
            display: flex;
            gap: 10px;
            justify-content: center;
        }

        .bid-actions button {
            padding: 8px 20px;
            font-size: 14px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
        }

        #bid-submit {
            background: #4CAF50;
            color: white;
        }

        #bid-submit:disabled {
            background: #444;
            cursor: not-allowed;
        }

        #bid-pass {
            background: #f44336;
            color: white;
        }

        /* 친구 선언 모달 */
        .quick-friend-selection {
            display: flex;
            gap: 15px;
            justify-content: center;
            margin-bottom: 20px;
        }

        .quick-friend-btn {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 8px;
            padding: 15px 25px;
            border: 3px solid #444;
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.2s;
            min-width: 140px;
        }

        .quick-friend-btn:hover {
            transform: scale(1.05);
        }

        .quick-friend-btn .btn-icon {
            font-size: 32px;
        }

        .quick-friend-btn .btn-text {
            font-size: 14px;
            font-weight: bold;
        }

        .quick-friend-btn .btn-card {
            font-size: 20px;
            font-weight: bold;
            padding: 5px 10px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 5px;
        }

        .quick-friend-btn .btn-card.red {
            color: #d32f2f;
        }

        .mighty-btn {
            background: linear-gradient(135deg, #FFD700 0%, #FFA500 100%);
            color: #000;
            border-color: #FFD700;
        }

        .mighty-btn:hover {
            box-shadow: 0 0 20px rgba(255, 215, 0, 0.5);
        }

        .joker-btn {
            background: linear-gradient(135deg, #9c27b0 0%, #e91e63 100%);
            color: white;
            border-color: #9c27b0;
        }

        .joker-btn:hover {
            box-shadow: 0 0 20px rgba(156, 39, 176, 0.5);
        }

        .manual-selection {
            margin-bottom: 20px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 8px;
            padding: 10px;
        }

        .manual-selection summary {
            cursor: pointer;
            padding: 10px;
            text-align: center;
            color: #aaa;
            font-size: 14px;
        }

        .manual-selection summary:hover {
            color: #fff;
        }

        .manual-selection[open] summary {
            margin-bottom: 15px;
            border-bottom: 1px solid #444;
        }

        .manual-confirm-btn {
            display: block;
            margin: 15px auto 0;
            padding: 10px 25px;
            background: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
        }

        .manual-confirm-btn:hover {
            background: #45a049;
        }

        .friend-selection {
            margin-bottom: 15px;
        }

        .suit-select,
        .rank-select {
            margin-bottom: 15px;
        }

        .rank-select .rank-buttons {
            display: flex;
            gap: 5px;
            flex-wrap: wrap;
            justify-content: center;
        }

        #friend-rank-buttons {
            display: flex;
            gap: 5px;
            flex-wrap: wrap;
            justify-content: center;
        }

        #friend-rank-buttons button {
            padding: 8px 12px;
            font-size: 14px;
            border: 2px solid #444;
            background: #333;
            color: white;
            border-radius: 5px;
            cursor: pointer;
        }

        #friend-rank-buttons button.selected {
            background: #4CAF50;
            border-color: #4CAF50;
        }

        #friend-suit-buttons {
            display: flex;
            gap: 15px;
            justify-content: center;
        }

        .friend-preview {
            text-align: center;
            font-size: 16px;
            margin-bottom: 10px;
            color: #4CAF50;
        }

        .friend-actions {
            display: flex;
            gap: 15px;
            justify-content: center;
            margin-top: 15px;
        }

        .friend-actions button {
            padding: 12px 25px;
            font-size: 16px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
        }

        #friend-confirm {
            background: #4CAF50;
            color: white;
        }

        #no-friend {
            background: #FF9800;
            color: white;
        }

        /* 카드 교환 모달 */
        #exchange-modal {
            min-width: 600px;
        }

        .exchange-hand {
            display: flex;
            gap: 5px;
            flex-wrap: wrap;
            justify-content: center;
            margin-bottom: 20px;
        }

        .exchange-hand .card {
            cursor: pointer;
        }

        .exchange-hand .card.selected {
            border-color: #f44336;
            transform: translateY(-10px);
        }

        .exchange-info {
            text-align: center;
            margin-bottom: 15px;
            font-size: 16px;
        }

        .giruda-change-section {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            padding: 12px 15px;
            margin-bottom: 15px;
        }

        .giruda-change-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
            font-weight: bold;
            font-size: 14px;
        }

        .giruda-change-cost {
            color: #ff9800;
            font-size: 13px;
        }

        .giruda-change-current {
            text-align: center;
            margin-bottom: 10px;
            font-size: 13px;
            color: #ccc;
        }

        .giruda-change-current .current-giruda {
            color: #4CAF50;
            font-weight: bold;
        }

        .giruda-change-current .current-bid {
            color: #2196F3;
            font-weight: bold;
        }

        .giruda-change-buttons {
            display: flex;
            justify-content: center;
            gap: 8px;
            flex-wrap: wrap;
        }

        .giruda-btn {
            padding: 8px 16px;
            font-size: 16px;
            border: 2px solid #555;
            border-radius: 5px;
            cursor: pointer;
            background: rgba(0, 0, 0, 0.3);
            color: white;
            transition: all 0.2s;
        }

        .giruda-btn:hover {
            background: rgba(255, 255, 255, 0.1);
        }

        .giruda-btn.selected {
            border-color: #4CAF50;
            background: rgba(76, 175, 80, 0.3);
        }

        .giruda-btn.current {
            border-color: #2196F3;
            background: rgba(33, 150, 243, 0.2);
        }

        .giruda-btn.red {
            color: #e53935;
        }

        .giruda-btn.black {
            color: #fff;
        }

        .giruda-btn:disabled {
            opacity: 0.4;
            cursor: not-allowed;
        }

        .giruda-btn.no-giruda {
            color: #9e9e9e;
            font-weight: bold;
            font-size: 14px;
        }

        .giruda-separator {
            color: #555;
            margin: 0 5px;
            align-self: center;
        }

        .solino-option {
            display: flex;
            align-items: center;
            gap: 5px;
            cursor: pointer;
            font-size: 13px;
            padding: 5px 10px;
            background: rgba(255, 152, 0, 0.2);
            border-radius: 5px;
            border: 1px solid #ff9800;
        }

        .solino-option:hover {
            background: rgba(255, 152, 0, 0.3);
        }

        .solino-option input[type="checkbox"] {
            width: 16px;
            height: 16px;
            cursor: pointer;
        }

        #exchange-confirm {
            display: block;
            margin: 0 auto;
            padding: 12px 40px;
            font-size: 16px;
            background: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
        }

        #exchange-confirm:disabled {
            background: #444;
            cursor: not-allowed;
        }

        /* 조커 수트 선언 모달 */
        #joker-suit-buttons {
            display: flex;
            gap: 15px;
            justify-content: center;
        }

        #joker-suit-buttons button {
            width: 70px;
            height: 70px;
            font-size: 36px;
            border: 3px solid #444;
            background: #333;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.2s;
        }

        #joker-suit-buttons button:hover {
            transform: scale(1.1);
            border-color: #4CAF50;
        }

        #joker-suit-buttons button.red {
            color: #d32f2f;
        }

/* ===== 게임 결과 모달 (전체화면 오버레이) ===== */
#result-modal {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.97);
    z-index: 2000;
    display: flex;
    justify-content: center;
    align-items: flex-start;
}

#result-modal.hidden {
    display: none !important;
}

.result-scroll-wrap {
    width: 100%;
    max-width: 700px;
    max-height: 100vh;
    max-height: 100dvh;
    overflow-y: auto;
    -webkit-overflow-scrolling: touch;
    padding: 30px 32px 40px;
}
#result-title {
    font-size: 36px;
    margin-bottom: 16px;
    text-align: center;
}

#result-title.win { color: #4CAF50; }
#result-title.lose { color: #f44336; }

#result-content {
    margin-bottom: 8px;
}

.result-summary {
    text-align: center;
    margin-bottom: 16px;
    font-size: 18px;
    color: #ccc;
}

.result-scores {
    background: rgba(255, 255, 255, 0.08);
    border-radius: 8px;
    padding: 12px 20px;
}

.result-header {
    display: flex;
    justify-content: space-between;
    padding: 6px 0;
    border-bottom: 2px solid rgba(255, 255, 255, 0.25);
    font-weight: bold;
    font-size: 16px;
    color: #999;
}

.result-header span:first-child { flex: 1; }
.result-header span:nth-child(2),
.result-header span:nth-child(3) { width: 70px; text-align: right; }

.score-row {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 8px 0;
    border-bottom: 1px solid rgba(255, 255, 255, 0.06);
    font-size: 20px;
}

.score-row:last-child { border-bottom: none; }
.score-row .player-name { font-weight: bold; flex: 1; font-size: 20px; }
.score-row .earned-points { width: 70px; text-align: right; color: #FFD700; font-weight: bold; }
.score-row .score-change { width: 70px; text-align: right; font-weight: bold; }

.score-row .score-change.positive { color: #4CAF50; }
.score-row .score-change.negative { color: #f44336; }

.friend-contribution-line {
    margin-top: 12px;
    padding: 10px 16px;
    background: rgba(255, 215, 0, 0.1);
    border-radius: 5px;
    border: 1px solid rgba(255, 215, 0, 0.2);
    font-size: 16px;
    color: #FFD700;
    text-align: center;
}

.game-history {
    margin-top: 10px;
    padding-top: 8px;
    border-top: 1px solid rgba(255, 255, 255, 0.15);
}

.history-header {
    font-size: 18px;
    font-weight: bold;
    color: #FFD700;
    margin-bottom: 8px;
    text-align: center;
}

.history-table-wrapper {
    max-height: 200px;
    overflow-y: auto;
    border-radius: 6px;
    background: rgba(0, 0, 0, 0.3);
}

.history-table {
    width: 100%;
    border-collapse: collapse;
    font-size: 15px;
}

.history-table th,
.history-table td {
    padding: 6px 6px;
    text-align: center;
    border-bottom: 1px solid rgba(255, 255, 255, 0.06);
}

.history-table th {
    background: rgba(0, 0, 0, 0.4);
    color: #888;
    font-weight: normal;
    position: sticky;
    top: 0;
    font-size: 14px;
}

.history-table td.positive { color: #4CAF50; }
.history-table td.negative { color: #f44336; }
.history-table td.gov-win { color: #4CAF50; font-weight: bold; }
.history-table td.opp-win { color: #2196F3; font-weight: bold; }

.history-table tfoot {
    background: rgba(0, 0, 0, 0.4);
}

.history-table tfoot td {
    padding: 3px 2px;
    border-top: 1px solid rgba(255, 255, 255, 0.2);
    font-weight: bold;
}

.result-buttons {
    display: flex;
    justify-content: center;
    gap: 12px;
    margin-top: 15px;
}

#new-game-btn {
    padding: 16px 50px;
    font-size: 20px;
    background: #4CAF50;
    color: white;
    border: none;
    border-radius: 6px;
    cursor: pointer;
}

#new-game-btn:hover { background: #45a049; }

#end-game-btn {
    padding: 16px 50px;
    font-size: 20px;
    background: #555;
    color: white;
    border: none;
    border-radius: 6px;
    cursor: pointer;
}

#end-game-btn:hover { background: #444; }



        /* 설정 모달 */
        .settings-content {
            margin-bottom: 20px;
        }

        .setting-group {
            margin-bottom: 20px;
        }

        .setting-group h4 {
            margin-bottom: 10px;
            padding-bottom: 5px;
            border-bottom: 1px solid #444;
        }

        .setting-group label {
            display: block;
            margin: 10px 0;
            cursor: pointer;
        }

        .setting-group select {
            padding: 5px 10px;
            font-size: 14px;
            margin-left: 10px;
        }

        .setting-hint {
            display: block;
            font-size: 11px;
            color: #888;
            margin-left: 22px;
            margin-top: 3px;
        }

        #settings-close {
            display: block;
            margin: 0 auto;
            padding: 10px 30px;
            font-size: 16px;
            background: #666;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
        }

        /* ===== 팀별 점수 진행 바 ===== */
        .score-progress {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-top: 5px;
            padding: 5px 10px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 5px;
        }

        .score-bar {
            flex: 1;
            height: 12px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 6px;
            overflow: hidden;
            position: relative;
        }

        .score-bar-fill {
            height: 100%;
            border-radius: 6px;
            transition: width 0.5s ease;
        }

        .score-bar-fill.government {
            background: linear-gradient(90deg, #4CAF50, #8BC34A);
        }

        .score-bar-fill.opposition {
            background: linear-gradient(90deg, #2196F3, #03A9F4);
        }

        .score-label {
            font-size: 12px;
            min-width: 80px;
        }

        .score-label.government {
            color: #4CAF50;
        }

        .score-label.opposition {
            color: #2196F3;
        }

        /* ===== 유틸리티 ===== */
        .hidden {
            display: none !important;
        }

/* ★ 카드 교환 모달 - 기존패 / 바닥패 구분 */
.exchange-section-label {
    font-size: 12px;
    color: #999;
    text-align: center;
    margin: 8px 0 4px;
    padding-bottom: 3px;
    border-bottom: 1px solid rgba(255, 255, 255, 0.15);
}

.exchange-section-label:first-child {
    margin-top: 0;
}

.exchange-section-label.floor-label {
    color: #FF9800;
    border-bottom-color: rgba(255, 152, 0, 0.3);
}

.exchange-hand-group {
    display: flex;
    gap: 5px;
    flex-wrap: wrap;
    justify-content: center;
    margin-bottom: 4px;
}

body.mobile-mode .exchange-section-label {
    font-size: 10px;
    margin: 5px 0 3px;
}


        /* ===== 애니메이션 ===== */
        @keyframes pulse {
            0% {
                box-shadow: 0 0 10px rgba(255, 215, 0, 0.5);
            }

            50% {
                box-shadow: 0 0 25px rgba(255, 215, 0, 0.8);
            }

            100% {
                box-shadow: 0 0 10px rgba(255, 215, 0, 0.5);
            }
        }

        .player-area.active-turn {
            animation: pulse 1.5s infinite;
        }

        @keyframes cardDeal {
            from {
                opacity: 0;
                transform: translateY(-50px) rotate(-10deg);
            }

            to {
                opacity: 1;
                transform: translateY(0) rotate(0);
            }
        }

        .card.dealing {
            animation: cardDeal 0.3s ease-out forwards;
        }

        @keyframes cardPlay {
            0% {
                opacity: 0;
                transform: scale(0.5);
            }

            50% {
                opacity: 0.8;
                transform: scale(1.1);
            }

            100% {
                opacity: 1;
                transform: scale(1);
            }
        }

        .trick-card .card {
            animation: cardPlay 0.4s ease-out;
        }

        @keyframes winnerGlow {
            0% {
                box-shadow: 0 0 10px rgba(255, 215, 0, 0.5);
            }

            50% {
                box-shadow: 0 0 30px rgba(255, 215, 0, 1);
            }

            100% {
                box-shadow: 0 0 10px rgba(255, 215, 0, 0.5);
            }
        }

        .trick-card.winner .card {
            animation: winnerGlow 1s infinite;
        }

        @keyframes scoreChange {
            0% {
                transform: scale(1);
            }

            50% {
                transform: scale(1.3);
                color: #FFD700;
            }

            100% {
                transform: scale(1);
            }
        }

        .player-score.changed {
            animation: scoreChange 0.5s ease;
        }

        /* ===== 반응형 ===== */
        @media (max-width: 1400px) {
            #app {
                padding-right: 280px;
            }

            #ai-log-panel {
                width: 260px;
            }

            .log-entry {
                font-size: 14px;
                padding: 6px 8px;
            }

            .log-entry .log-header {
                font-size: 16px;
            }

            .log-entry .log-reasons {
                font-size: 12px;
            }
        }

        @media (max-width: 1200px) {
            #app {
                padding-right: 10px;
            }

            #ai-log-panel {
                top: auto;
                bottom: 0;
                right: 10px;
                width: 300px;
                max-height: 200px;
                border-radius: 10px 10px 0 0;
            }

            .log-entry {
                font-size: 14px;
                padding: 6px 8px;
            }

            .log-entry .log-header {
                font-size: 16px;
            }

            .log-entry .log-reasons {
                font-size: 12px;
            }

            .player-area.top-left,
            .player-area.top-right {
                width: 220px;
            }

            .player-area.left,
            .player-area.right {
                width: 220px;
            }

            .player-area.user {
                width: 550px;
                padding: 5px 10px;
            }

            .player-area.user .card {
                width: 86px;
                height: 116px;
            }

            .player-hand .card {
                margin-left: -45px;
            }

            .player-area.left .player-hand .card,
            .player-area.right .player-hand .card {
                margin-left: -45px;
            }


            .player-area.user .player-hand .card {
                margin-left: 0;
            }

            .modal {
                left: 50%;
            }
        }

        @media (max-width: 900px) {
            .game-info {
                gap: 10px;
            }

            .game-info span {
                font-size: 12px;
                padding: 3px 8px;
            }

            .player-area.left,
            .player-area.right {
                width: 160px;
            }

            .card {
                width: 86px;
                height: 116px;
            }

            .player-area.user .card {
                width: 86px;
                height: 116px;
            }

            .player-hand .card {
                margin-left: -45px;
            }

            .player-area.left .player-hand .card,
            .player-area.right .player-hand .card {
                margin-left: -45px;
            }


            .player-area.user .player-hand .card {
                margin-left: 0;
            }

            .player-area.top-left,
            .player-area.top-right {
                width: 160px;
            }

            .player-area.user {
                width: 400px;
                padding: 4px 8px;
            }

            .trick-cards {
                width: 260px;
                height: 180px;
            }

            .trick-card {
                position: absolute;
                width: 86px;
                height: 116px;


            .trick-card[data-player="2"] {
                left: 100px;
            }

            .trick-card[data-player="3"] {
                right: 100px;
            }


            #ai-log-panel {
                width: 260px;
            }

            .log-entry {
                font-size: 12px;
                padding: 5px 6px;
            }

            .log-entry .log-header {
                font-size: 14px;
            }

            .log-entry .log-reasons {
                font-size: 11px;
            }

            #bidding-modal {
                min-width: 280px;
                max-width: 320px;
            }
        }
    
/* ============================================ */
/* ===== 모바일 전용 스타일 ===== */
/* ============================================ */

/* ★ 모바일 2x2 그리드 배경 기루다 심볼 */
body.mobile-mode #mobile-ai-grid {
    position: relative;
}

#mobile-giruda-bg {
    display: none;
}

body.mobile-mode #mobile-giruda-bg {
    display: block;
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    font-size: 120px;
    font-weight: bold;
    pointer-events: none;
    z-index: 0;
    opacity: 0.7;
    line-height: 1;
    text-shadow: 0 0 20px currentColor;
}


body.mobile-mode .mobile-ai-cell {
    position: relative;
    z-index: 1;
}


body.mobile-mode .controls {
    display: none !important;
}

body.mobile-mode #ai-log-panel {
    display: none !important;
}

body.mobile-mode #info-bar {
    padding: 3px 8px;
    margin-bottom: 2px;
}

body.mobile-mode .game-info {
    gap: 6px;
}

body.mobile-mode .game-info span {
    font-size: 11px;
    padding: 2px 6px;
}

/* ★ 데스크톱 전용 영역 숨기기 */
body.mobile-mode .top-row,
body.mobile-mode .middle-row {
    display: none !important;
}

/* ★★★ 모바일 AI 2x2 그리드 ★★★ */
body.mobile-mode #mobile-ai-grid {
    display: grid !important;
    grid-template-columns: 1fr 1fr;
    gap: 4px;
    padding: 4px 6px;
}

.mobile-ai-cell {
    background: rgba(0, 0, 0, 0.15);
    border-radius: 6px;
    padding: 4px 6px;
    display: flex;
    flex-direction: column;
    min-height: 60px;
    border: 2px solid transparent;
    transition: all 0.3s;
}

.mobile-ai-cell.active-turn-cell {
    background: rgba(0, 0, 0, 0.2);
    border-color: #FFD700;
    box-shadow: 0 0 8px rgba(255, 215, 0, 0.6);
    animation: pulse 1.5s infinite;
}

.mobile-ai-cell .cell-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 2px;
    font-size: 11px;
}

.mobile-ai-cell .cell-name {
    font-weight: bold;
    font-size: 12px;
}

.mobile-ai-cell .cell-role {
    font-size: 9px;
    padding: 1px 5px;
    border-radius: 3px;
}

.mobile-ai-cell .cell-role.master { background:#FFD700;color:#000; }
.mobile-ai-cell .cell-role.friend { background:#FF69B4;color:#000; }
.mobile-ai-cell .cell-role.opposition { background:#555;color:#fff; }

.mobile-ai-cell .cell-info {
    display: none;
}

.mobile-ai-cell .cell-header .cell-score {
    font-size: 10px;
    color: #FFD700;
    font-weight: bold;
    margin: 0 auto 0 6px;
}


/* ★ 각 AI 박스 안의 트릭 카드 표시 영역 */
.mobile-ai-cell .cell-trick-card {
    display: flex;
    justify-content: center;
    align-items: center;
    min-height: 61px;
    margin-top: 2px;
}



.mobile-ai-cell .cell-trick-card .card {
    width: 46px;
    height: 61px;
}



.mobile-ai-cell .cell-trick-card .card .card-image,
.mobile-ai-cell .cell-trick-card .card .joker-image {
    width: 100%;
    height: 100%;
    object-fit: contain;
}

.mobile-ai-cell .cell-trick-card.winner .card {
    box-shadow: 0 0 12px rgba(255, 215, 0, 0.9);
    border-radius: 4px;
    border: 2px solid #FFD700;
    animation: mobileWinnerGlow 1s infinite;
}

#mobile-user-trick.winner .card {
    box-shadow: 0 0 12px rgba(255, 215, 0, 0.9);
    border-radius: 4px;
    border: 2px solid #FFD700;
    animation: mobileWinnerGlow 1s infinite;
}

@keyframes mobileWinnerGlow {
    0%   { box-shadow: 0 0 6px rgba(255, 215, 0, 0.5);  border-color: #FFD700; }
    50%  { box-shadow: 0 0 20px rgba(255, 215, 0, 1);    border-color: #fff; }
    100% { box-shadow: 0 0 6px rgba(255, 215, 0, 0.5);  border-color: #FFD700; }
}


/* ★ 비딩 중 말풍선 표시 */
.mobile-ai-cell .cell-bid-bubble {
    text-align: center;
    font-size: 11px;
    font-weight: bold;
    color: #FFD700;
    padding: 3px 6px;
    margin-top: 2px;
    background: rgba(255, 215, 0, 0.1);
    border-radius: 4px;
    min-height: 20px;
}

/* ★ 모바일 중앙 유저 트릭 카드 + 점수 바 영역 */
#mobile-center-area {
    display: none !important;
}
body.mobile-mode #mobile-center-area {
    display: flex !important;
}


body.mobile-mode #mobile-center-area {
    display: flex !important;
    flex-direction: column;
    align-items: center;
    padding: 2px 6px;
    gap: 2px;
}

#mobile-user-trick {
    display: flex;
    justify-content: center;
    align-items: center;
    min-height: 61px;
}


#mobile-user-trick .card {
    width: 46px;
    height: 61px;
}


#mobile-user-trick .card .card-image,
#mobile-user-trick .card .joker-image {
    width: 100%;
    height: 100%;
    object-fit: contain;
}

#mobile-user-trick.winner .card {
    box-shadow: 0 0 12px rgba(255, 215, 0, 0.9);
    border-radius: 4px;
}

#mobile-trick-info {
    font-size: 10px;
    text-align: center;
    color: #ccc;
    background: rgba(0, 0, 0, 0.3);
    padding: 2px 8px;
    border-radius: 4px;
}

/* ★ 데스크톱 트릭 영역은 모바일에서 숨기기 */
body.mobile-mode #trick-area {
    display: none !important;
}

body.mobile-mode .score-progress {
    gap: 4px;
    padding: 2px 6px;
    margin-top: 2px;
}

body.mobile-mode .score-label { font-size:10px;min-width:60px; }
body.mobile-mode .score-bar { height:8px; }

/* ★ 유저 영역 */
body.mobile-mode .bottom-row { justify-content:center; }

body.mobile-mode .player-area.user {
    width: 100%;
    max-width: 100vw;
    padding: 2px 4px;
}

body.mobile-mode .player-area.user .player-hand {
    min-height: 50px;
    padding-left: 0;
    justify-content: center;
    flex-wrap: wrap;
    gap: 3px 3px;
}

body.mobile-mode .player-area.user .card {
    width: 46px;
    height: 61px;
    flex-shrink: 0;
}


body.mobile-mode .player-area.user .player-hand .card {
    margin-left: 0;
}

body.mobile-mode .player-area.user .player-hand .card:first-child {
    margin-left: 0;
}


body.mobile-mode .player-area.user .player-header {
    flex-direction: row !important;
    justify-content: space-between !important;
    align-items: center !important;
    padding-bottom: 1px !important;
    margin-bottom: 1px !important;
    border-bottom: 1px solid rgba(255,255,255,0.1) !important;
}

body.mobile-mode .player-area.user .player-name {
    display: none !important;
}

body.mobile-mode .player-area.user .player-score {
    font-size: 11px;
    margin-top: 0;
    text-align: left;
    order: -1;
}

body.mobile-mode .player-area.user .player-role {
    font-size: 10px;
    margin-left: auto;
}

body.mobile-mode .player-area.user .player-hand {
    margin-top: 0;
}

body.mobile-mode .player-area.user > .player-score {
    display: none !important;
}



body.mobile-mode .card .special-label {
    font-size: 7px;
    padding: 1px 3px;
    top: -6px;
    right: -6px;
}

body.mobile-mode #action-area {
    padding: 4px 6px;
    min-height: 30px;
    gap: 3px;
}

body.mobile-mode #action-message { font-size:12px; }
body.mobile-mode #action-buttons button { padding:6px 14px;font-size:12px; }

body.mobile-mode #giruda-bg-symbol {
    font-size: 100px !important;
}

/* 모바일 모달 공통 */
body.mobile-mode .modal {
    min-width: 0;
    width: calc(100vw - 16px);
    max-width: 340px;
    left: 50%;
    top: 50%;
    transform: translate(-50%, -50%);
    padding: 10px 12px;
    max-height: calc(100vh - 20px);
    overflow-y: auto;
    border-radius: 10px;
}

body.mobile-mode .modal h3 { font-size:15px;margin-bottom:8px; }
body.mobile-mode .modal p { font-size:11px;margin-bottom:6px; }

body.mobile-mode #bidding-modal {
    top: 50%;
    transform: translate(-50%, -50%);
}

body.mobile-mode #bidding-modal h3 {
    font-size: 13px !important;
    margin-bottom: 4px !important;
}

body.mobile-mode .current-bid { font-size:11px;padding:3px;margin-bottom:4px; }
body.mobile-mode .bid-controls label { font-size:10px; }
body.mobile-mode .bid-number, body.mobile-mode .bid-suit { margin-bottom:4px; }
body.mobile-mode .number-buttons button { padding:4px 5px;font-size:10px;min-width:22px; }
body.mobile-mode .suit-buttons button { width:30px;height:30px;font-size:15px; }
body.mobile-mode .bid-preview { font-size:12px;padding:3px;margin-bottom:6px; }
body.mobile-mode .bid-actions button { padding:6px 14px;font-size:12px; }


body.mobile-mode #bid-hand-preview {
    padding: 4px 2px !important;
    margin-bottom: 6px !important;
    display: flex !important;
    flex-wrap: wrap !important;
    justify-content: center !important;
    gap: 2px 2px !important;
    overflow: visible !important;
}

body.mobile-mode #bid-hand-preview .card {
    width: 46px !important;
    height: 61px !important;
    margin-left: 0 !important;
    flex-shrink: 0 !important;
}



body.mobile-mode #bid-hand-preview .card:first-child {
    margin-left: 0 !important;
}



body.mobile-mode .quick-friend-selection {
    gap:6px;margin-bottom:10px;flex-wrap:wrap;
}

body.mobile-mode .quick-friend-btn {
    padding:8px 12px;min-width:90px;gap:4px;border-width:2px;
}

body.mobile-mode .quick-friend-btn .btn-icon { font-size:20px; }
body.mobile-mode .quick-friend-btn .btn-text { font-size:11px; }
body.mobile-mode .quick-friend-btn .btn-card { font-size:14px;padding:2px 6px; }
body.mobile-mode .friend-actions { margin-top:8px;gap:8px; }
body.mobile-mode .friend-actions button { padding:8px 16px;font-size:13px; }
body.mobile-mode .manual-selection summary { font-size:12px;padding:6px; }

body.mobile-mode #exchange-modal { min-width:0;max-width:360px; }
body.mobile-mode .exchange-hand .card { width:46px;height:61px; }

body.mobile-mode .exchange-info { font-size:12px; margin-top:2px; margin-bottom:2px; }

body.mobile-mode .giruda-change-section { padding:4px 8px; margin-bottom:8px; }
body.mobile-mode .giruda-change-header { font-size:10px; gap:4px; }
body.mobile-mode .giruda-change-cost { font-size:9px; }
body.mobile-mode .giruda-change-current { font-size:10px; margin-bottom:4px; }

body.mobile-mode .giruda-btn { padding:5px 10px;font-size:14px; }

body.mobile-mode #joker-suit-buttons button { width:50px;height:50px;font-size:26px; }
body.mobile-mode #joker-suit-buttons { gap:10px; }

body.mobile-mode #result-modal {
    min-width: 0;
    max-width: 100vw;
    width: 100%;
    top: 0;
    left: 0;
    transform: none;
    max-height: 100vh;
    max-height: 100dvh;
    overflow-y: auto;
    padding: 0;
}

body.mobile-mode .result-scroll-wrap {
    max-width: 100%;
    padding: 16px 16px 24px;
}

body.mobile-mode #result-title { font-size: 22px; margin-bottom: 12px; }

body.mobile-mode #result-content { margin-bottom: 12px; }

body.mobile-mode .result-summary {
    font-size: 15px;
    margin-bottom: 12px;
    line-height: 1.4;
}

body.mobile-mode .result-scores { padding: 10px 14px; }

body.mobile-mode .result-header {
    font-size: 13px;
    padding: 5px 0;
}

body.mobile-mode .result-header span:nth-child(2),
body.mobile-mode .result-header span:nth-child(3) {
    width: 55px;
}

body.mobile-mode .score-row {
    font-size: 16px;
    padding: 6px 0;
}

body.mobile-mode .score-row .player-name { font-size: 16px; }

body.mobile-mode .score-row .earned-points,
body.mobile-mode .score-row .score-change {
    width: 55px;
    font-size: 16px;
}

body.mobile-mode .friend-contribution-line {
    margin-top: 10px;
    padding: 8px 12px;
    font-size: 14px;
}

body.mobile-mode .friend-contribution {
    margin-top: 8px;
    padding: 8px 12px;
}

body.mobile-mode .contribution-header { font-size: 14px; margin-bottom: 4px; }
body.mobile-mode .contribution-details { gap: 6px; }
body.mobile-mode .contribution-item { padding: 3px 8px; }
body.mobile-mode .contribution-label { font-size: 12px; }
body.mobile-mode .contribution-value { font-size: 14px; }

body.mobile-mode .game-history {
    margin-top: 12px;
    padding-top: 10px;
}

body.mobile-mode .history-header { font-size: 16px; margin-bottom: 6px; }

body.mobile-mode .history-table { font-size: 13px; }
body.mobile-mode .history-table th { font-size: 12px; padding: 5px 4px; }
body.mobile-mode .history-table td { padding: 5px 4px; }
body.mobile-mode .history-table-wrapper { max-height: 150px; }
body.mobile-mode .history-legend { font-size: 12px; gap: 8px; margin-top: 4px; }

body.mobile-mode .result-buttons {
    margin-top: 14px;
    gap: 12px;
}

body.mobile-mode #new-game-btn,
body.mobile-mode #end-game-btn {
    padding: 12px 30px;
    font-size: 16px;
}



/* 기존 요소 숨기기 */
#mobile-ai-grid { display: none !important; }
body.mobile-mode #mobile-ai-grid { display: grid !important; }

#mobile-ai-bar { display: none; }

/* ===== 최종 요약 전체화면 오버레이 ===== */
#final-summary-overlay {
    position: fixed;
    top: 0; left: 0; right: 0; bottom: 0;
    width: 100%; height: 100%;
    background: rgba(0, 0, 0, 0.97);
    z-index: 3000;
    display: flex;
    justify-content: center;
    align-items: center;
    overflow-y: auto;
    -webkit-overflow-scrolling: touch;
}

#final-summary-overlay.hidden {
    display: none !important;
}

.final-summary-content {
    width: 100%;
    max-width: 600px;
    padding: 40px 32px 50px;
    color: #e0e0e0;
}

.final-summary-content h2 {
    text-align: center;
    font-size: 36px;
    margin-bottom: 16px;
}

.final-summary-content .fs-subtitle {
    text-align: center;
    color: #aaa;
    font-size: 18px;
    margin-bottom: 24px;
}

.final-summary-content .fs-player-row {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 14px 20px;
    margin: 6px 0;
    border-radius: 8px;
    background: rgba(255, 255, 255, 0.08);
    font-size: 22px;
}

.final-summary-content .fs-player-row.winner {
    border: 3px solid #FFD700;
    background: rgba(255, 215, 0, 0.15);
}

.final-summary-content .fs-player-name {
    font-weight: bold;
    font-size: 22px;
}

.final-summary-content .fs-score.positive { color: #4CAF50; font-weight: bold; font-size: 22px; }
.final-summary-content .fs-score.negative { color: #f44336; font-weight: bold; font-size: 22px; }

.final-summary-content .fs-footer {
    text-align: center;
    color: #666;
    font-size: 16px;
    margin-top: 30px;
}

.final-summary-content .fs-reload-btn {
    display: block;
    margin: 24px auto 0;
    padding: 16px 50px;
    font-size: 20px;
    background: #4CAF50;
    color: white;
    border: none;
    border-radius: 8px;
    cursor: pointer;
}

.final-summary-content .fs-reload-btn:hover {
    background: #45a049;
}

/* 모바일 최종 요약 축소 */
body.mobile-mode .final-summary-content {
    padding: 12px 10px 20px;
    max-width: 320px;
}

body.mobile-mode .final-summary-content h2 {
    font-size: 18px;
    margin-bottom: 4px;
}

body.mobile-mode .final-summary-content .fs-subtitle {
    font-size: 11px;
    margin-bottom: 10px;
}

body.mobile-mode .final-summary-content .fs-player-row {
    padding: 6px 10px;
    margin: 3px 0;
    font-size: 13px;
}

body.mobile-mode .final-summary-content .fs-reload-btn {
    padding: 10px 24px;
    font-size: 13px;
}

body.mobile-mode .final-summary-content .fs-footer {
    font-size: 10px;
}

/* ===== 모바일 점수 진행 바 ===== */
#mobile-score-progress {
    display: none !important;
}
body.mobile-mode #mobile-score-progress {
    display: flex !important;
}


body.mobile-mode #mobile-score-progress {
    display: flex;
    align-items: center;
    gap: 4px;
    padding: 3px 8px;
    background: rgba(0, 0, 0, 0.4);
    border-radius: 5px;
    width: 100%;
    max-width: 100vw;
    box-sizing: border-box;
}

body.mobile-mode #mobile-score-progress .score-label {
    font-size: 10px;
    min-width: 65px;
    white-space: nowrap;
}

body.mobile-mode #mobile-score-progress .score-label.government {
    color: #4CAF50;
    text-align: right;
}

body.mobile-mode #mobile-score-progress .score-label.opposition {
    color: #2196F3;
    text-align: left;
}

body.mobile-mode #mobile-score-progress .score-bar {
    flex: 1;
    height: 8px;
    background: rgba(255, 255, 255, 0.1);
    border-radius: 4px;
    overflow: hidden;
}

body.mobile-mode #mobile-score-progress .score-bar-fill {
    height: 100%;
    border-radius: 4px;
    transition: width 0.5s ease;
}

body.mobile-mode #mobile-score-progress .score-bar-fill.government {
    background: linear-gradient(90deg, #4CAF50, #8BC34A);
}

body.mobile-mode #mobile-score-progress .score-bar-fill.opposition {
    background: linear-gradient(90deg, #2196F3, #03A9F4);
}

</style>
</head>

<body>
    <div id="app">
        <header id="info-bar">
            <div class="game-info">
                <span id="round-info">라운드: -/10</span>
                <span id="contract-info">공약: -</span>
                <span id="friend-card-info">친구: ?</span>
            </div>
            <div class="controls">
                <button id="test-mode-toggle">🔧 테스트모드 OFF</button>
                <button id="settings-btn">⚙️ 설정</button>
            </div>
        </header>
<!-- 모바일 전용 AI 2x2 그리드 -->
<div id="mobile-ai-grid" style="display:none">
    <div class="mobile-ai-cell" data-ai="2">
        <div class="cell-header">
            <span class="cell-name">AI-2</span>
            <span class="cell-score">0점</span>
            <span class="cell-role"></span>
        </div>
        <div class="cell-bid-bubble"></div>
        <div class="cell-trick-card"></div>
    </div>
    <div class="mobile-ai-cell" data-ai="3">
    <div class="cell-header">
        <span class="cell-name">AI-3</span>
        <span class="cell-score">0점</span>
        <span class="cell-role"></span>
    </div>
    <div class="cell-bid-bubble"></div>
    <div class="cell-trick-card"></div>
</div>
<div class="mobile-ai-cell" data-ai="1">
    <div class="cell-header">
        <span class="cell-name">AI-1</span>
        <span class="cell-score">0점</span>
        <span class="cell-role"></span>
    </div>
    <div class="cell-bid-bubble"></div>
    <div class="cell-trick-card"></div>
</div>
<div class="mobile-ai-cell" data-ai="4">
    <div class="cell-header">
        <span class="cell-name">AI-4</span>
        <span class="cell-score">0점</span>
        <span class="cell-role"></span>
    </div>
    <div class="cell-bid-bubble"></div>
    <div class="cell-trick-card"></div>
</div>

    <div id="mobile-giruda-bg"></div>
</div>


<!-- 모바일 전용 유저 트릭 카드 + 정보 + 점수 바 -->
<div id="mobile-center-area">
    <div id="mobile-score-progress"></div>
    <div id="mobile-user-trick"></div>
    <div id="mobile-trick-info"></div>
</div>



        <main id="game-area">
            <div class="top-row">
                <div id="player-2" class="player-area top-left">
                    <div class="player-header">
                        <span class="player-name">AI-2</span>
                        <span class="player-role"></span>
                    </div>
                    <div class="player-hand"></div>
                    <div class="player-score">점수: <span>0</span>점</div>
                </div>
                <div id="player-3" class="player-area top-right">
                    <div class="player-header">
                        <span class="player-name">AI-3</span>
                        <span class="player-role"></span>
                    </div>
                    <div class="player-hand"></div>
                    <div class="player-score">점수: <span>0</span>점</div>
                </div>
            </div>

            <div class="middle-row">
                <div id="player-1" class="player-area left">
                    <div class="player-header">
                        <span class="player-name">AI-1</span>
                        <span class="player-role"></span>
                    </div>
                    <div class="player-hand"></div>
                    <div class="player-score">점수: <span>0</span>점</div>
                </div>

                <div id="trick-area">
                    <div class="trick-cards">
                        <div class="trick-card" data-player="2"></div>
                        <div class="trick-card" data-player="1"></div>
                        <div class="trick-card" data-player="3"></div>
                        <div class="trick-card" data-player="4"></div>
                        <div class="trick-card" data-player="0"></div>
                    </div>
                    <div id="trick-info"></div>
                </div>

                <div id="player-4" class="player-area right">
                    <div class="player-header">
                        <span class="player-name">AI-4</span>
                        <span class="player-role"></span>
                    </div>
                    <div class="player-hand"></div>
                    <div class="player-score">점수: <span>0</span>점</div>
                </div>
            </div>

            <div class="bottom-row">
                <div id="player-0" class="player-area user">
                    <div class="player-header">
                        <span class="player-name">나</span>
                        <span class="player-role"></span>
                    </div>
                    <div class="player-hand"></div>
                    <div class="player-score">점수: <span>0</span>점</div>
                </div>
            </div>
        </main>

        <div id="action-area">
            <div id="action-message"></div>
            <div id="action-buttons"></div>
            <div id="timer"></div>
        </div>

        <div id="ai-log-panel">
            <div class="panel-header">
                <span>AI 의사결정 로그</span>
                <button id="log-toggle">▼</button>
            </div>
            <div class="panel-content" id="ai-log-content"></div>
        </div>

        <div id="modal-overlay" class="hidden">
            <div id="modal-content"></div>
        </div>

        <div id="bidding-modal" class="modal hidden">
            <h3>비딩</h3>
            <div class="current-bid">현재 최고 비딩: <span id="current-bid-display">없음</span></div>
            <div class="bid-controls">
                <div class="bid-number">
                    <label>숫자:</label>
                    <div class="number-buttons" id="bid-numbers"></div>
                </div>
                <div class="bid-suit">
                    <label>기루다:</label>
                    <div class="suit-buttons" id="bid-suits"></div>
                </div>
            </div>
            <div class="bid-preview">나의 비딩: <span id="bid-preview">-</span></div>
            <div class="bid-actions">
                <button id="bid-submit" disabled>비딩하기</button>
                <button id="bid-pass">패스</button>
            </div>
        </div>

        <div id="friend-modal" class="modal hidden">
            <h3>친구 선언</h3>
            <p>친구로 지정할 카드를 선택하세요.</p>
            <div class="quick-friend-selection">
                <button id="friend-mighty" class="quick-friend-btn mighty-btn">
                    <span class="btn-icon">👑</span>
                    <span class="btn-text">마이티 친구</span>
                    <span class="btn-card" id="mighty-card-display">♠A</span>
                </button>
                <button id="friend-joker" class="quick-friend-btn joker-btn">
                    <span class="btn-icon">🃏</span>
                    <span class="btn-text">조커 친구</span>
                    <span class="btn-card">JOKER</span>
                </button>
            </div>
            <details class="manual-selection">
                <summary>직접 카드 선택</summary>
                <div class="friend-selection">
                    <div class="suit-select">
                        <label>수트:</label>
                        <div id="friend-suit-buttons"></div>
                    </div>
                    <div class="rank-select">
                        <label>숫자:</label>
                        <div id="friend-rank-buttons"></div>
                    </div>
                </div>
                <div class="friend-preview">선택한 카드: <span id="friend-preview">-</span></div>
                <button id="friend-confirm" class="manual-confirm-btn">선택 완료</button>
            </details>
            <div class="friend-actions">
                <button id="no-friend">노프렌드</button>
            </div>
        </div>

        <div id="exchange-modal" class="modal hidden">
            <h3>카드 교환</h3>
            <p>바닥에 버릴 카드 3장을 선택하세요.</p>
            <div class="exchange-hand" id="exchange-hand"></div>
            <div class="exchange-info">선택: <span id="exchange-count">0</span>/3</div>
            <div class="giruda-change-section" id="giruda-change-section">
                <div class="giruda-change-header">
                    <span>기루다 변경</span>
                    <span class="giruda-change-cost" id="giruda-change-cost"></span>
                </div>
                <div class="giruda-change-current" id="giruda-current-info"></div>
                <div class="giruda-change-buttons" id="giruda-change-buttons"></div>
            </div>
            <button id="exchange-confirm" disabled>확인</button>
        </div>

        <div id="joker-call-modal" class="modal hidden">
            <h3>조커 수트 선언</h3>
            <p>상대방이 내야 할 수트를 선택하세요.</p>
            <div id="joker-suit-buttons"></div>
        </div>
<div id="final-summary-overlay" class="hidden"></div>

        <div id="result-modal" class="hidden">
            <div class="result-scroll-wrap">
                <h3 id="result-title">게임 결과</h3>
                <div id="result-content"></div>
                <div class="result-buttons">
                    <button id="new-game-btn">계속 하기</button>
                    <button id="end-game-btn">끝내기</button>
                </div>
            </div>
        </div>


        <div id="settings-modal" class="modal hidden">
            <h3>설정</h3>
            <div class="settings-content">
                <div class="setting-group">
                    <h4>테스트 모드</h4>
                    <label>
                        <input type="checkbox" id="setting-show-ai-cards" checked>
                        AI 카드 공개
                    </label>
                    <label>
                        <input type="checkbox" id="setting-show-ai-log" checked>
                        AI 의사결정 로그
                    </label>
                    <label>
                        <input type="checkbox" id="setting-highlight-playable" checked>
                        낼 수 있는 카드 표시
                    </label>
                </div>
                <div class="setting-group">
                    <h4>AI 설정</h4>
                    <label>
                        AI 속도:
                        <select id="setting-ai-speed">
                            <option value="2000">느림 (2초)</option>
                            <option value="1000" selected>보통 (1초)</option>
                            <option value="300">빠름 (0.3초)</option>
                            <option value="0">즉시</option>
                        </select>
                    </label>
                </div>
                <div class="setting-group">
                    <h4>게임 규칙</h4>
                    <label>
                        <input type="checkbox" id="setting-use-sayeon" checked>
                        사연(四然) 기능
                        <span class="setting-hint">주공이 첫 카드 전에 친구의 조커 보유 여부 확인</span>
                    </label>
                </div>
            </div>
            <button id="settings-close">닫기</button>
        </div>
    </div>

    <script>
        // ========================================
        // ===== constants.js =====
        // ========================================

        const SUITS = {
            SPADE: 'spade',
            DIAMOND: 'diamond',
            HEART: 'heart',
            CLUB: 'club'
        };

        const SUIT_SYMBOLS = {
            [SUITS.SPADE]: '♠',
            [SUITS.DIAMOND]: '◆',
            [SUITS.HEART]: '♥',
            [SUITS.CLUB]: '♣'
        };

        const SUIT_NAMES = {
            [SUITS.SPADE]: '스페이드',
            [SUITS.DIAMOND]: '다이아',
            [SUITS.HEART]: '하트',
            [SUITS.CLUB]: '클로버'
        };

        const SUIT_STRENGTH = {
            [SUITS.SPADE]: 4,
            [SUITS.DIAMOND]: 3,
            [SUITS.HEART]: 2,
            [SUITS.CLUB]: 1,
            'none': 0
        };

        const RANKS = ['A', 'K', 'Q', 'J', '10', '9', '8', '7', '6', '5', '4', '3', '2'];

        const RANK_VALUES = {
            'A': 14, 'K': 13, 'Q': 12, 'J': 11, '10': 10,
            '9': 9, '8': 8, '7': 7, '6': 6, '5': 5, '4': 4, '3': 3, '2': 2
        };

        const POINT_RANKS = ['A', 'K', 'Q', 'J', '10'];

        const PHASES = {
            WAITING: 'waiting',
            DEALING: 'dealing',
            DEAL_CHECK: 'dealCheck',
            BIDDING: 'bidding',
            EXCHANGING: 'exchanging',
            FRIEND_DECLARATION: 'friendDeclaration',
            PLAYING: 'playing',
            TRICK_END: 'trickEnd',
            GAME_END: 'gameEnd'
        };

        const ROLES = {
            MASTER: 'master',
            FRIEND: 'friend',
            OPPOSITION: 'opposition',
            UNKNOWN: 'unknown'
        };

        const GAME_CONFIG = {
            PLAYER_COUNT: 5,
            CARDS_PER_PLAYER: 10,
            FLOOR_CARDS: 3,
            TOTAL_ROUNDS: 10,
            MIN_BID: 13,
            MAX_BID: 20,
            TOTAL_POINTS: 20
        };

        const DEFAULT_SETTINGS = {
            showAICards: false,
            showAILog: false,
            highlightPlayable: false,
            aiSpeed: 1000,
            useSayeon: true
        };


        const CARD_IMAGE_BASE = 'https://deckofcardsapi.com/static/img/';

        const CARD_IMAGE_CODES = {
            'spade_A': 'AS', 'spade_2': '2S', 'spade_3': '3S', 'spade_4': '4S', 'spade_5': '5S',
            'spade_6': '6S', 'spade_7': '7S', 'spade_8': '8S', 'spade_9': '9S', 'spade_10': '0S',
            'spade_J': 'JS', 'spade_Q': 'QS', 'spade_K': 'KS',
            'diamond_A': 'AD', 'diamond_2': '2D', 'diamond_3': '3D', 'diamond_4': '4D', 'diamond_5': '5D',
            'diamond_6': '6D', 'diamond_7': '7D', 'diamond_8': '8D', 'diamond_9': '9D', 'diamond_10': '0D',
            'diamond_J': 'JD', 'diamond_Q': 'QD', 'diamond_K': 'KD',
            'heart_A': 'AH', 'heart_2': '2H', 'heart_3': '3H', 'heart_4': '4H', 'heart_5': '5H',
            'heart_6': '6H', 'heart_7': '7H', 'heart_8': '8H', 'heart_9': '9H', 'heart_10': '0H',
            'heart_J': 'JH', 'heart_Q': 'QH', 'heart_K': 'KH',
            'club_A': 'AC', 'club_2': '2C', 'club_3': '3C', 'club_4': '4C', 'club_5': '5C',
            'club_6': '6C', 'club_7': '7C', 'club_8': '8C', 'club_9': '9C', 'club_10': '0C',
            'club_J': 'JC', 'club_Q': 'QC', 'club_K': 'KC'
        };

        function getCardImageUrl(suit, rank) {
            const key = `${suit}_${rank}`;
            const code = CARD_IMAGE_CODES[key];
            if (code) return `${CARD_IMAGE_BASE}${code}.png`;
            return null;
        }

        const CARD_BACK_IMAGE = 'https://deckofcardsapi.com/static/img/back.png';
        const JOKER_IMAGE = 'https://deckofcardsapi.com/static/img/X1.png';

        // ========================================
        // ===== EventBus (신규) =====
        // ========================================

        class EventBus {
            constructor() {
                this.listeners = new Map();
            }
            on(event, callback) {
                if (!this.listeners.has(event)) this.listeners.set(event, []);
                this.listeners.get(event).push(callback);
                return () => {
                    const cbs = this.listeners.get(event);
                    const idx = cbs.indexOf(callback);
                    if (idx > -1) cbs.splice(idx, 1);
                };
            }
            emit(event, data) {
                const cbs = this.listeners.get(event) || [];
                for (const cb of cbs) cb(data);
            }
            once(event, callback) {
                const unsub = this.on(event, (data) => { callback(data); unsub(); });
            }
        }

        const eventBus = new EventBus();

        // ========================================
        // ===== card.js =====
        // ========================================

        class Card {
            constructor(suit, rank) {
                this.suit = suit;
                this.rank = rank;
                this.isJoker = false;
            }

            static createJoker() {
                const card = new Card(null, 'JOKER');
                card.isJoker = true;
                return card;
            }

            equals(other) {
                if (!other) return false;
                if (this.isJoker && other.isJoker) return true;
                return this.suit === other.suit && this.rank === other.rank;
            }

            toString() {
                if (this.isJoker) return 'JOKER';
                return `${SUIT_SYMBOLS[this.suit]}${this.rank}`;
            }

            isPointCard() {
                if (this.isJoker) return false;
                return POINT_RANKS.includes(this.rank);
            }

            isRed() {
                return this.suit === SUITS.DIAMOND || this.suit === SUITS.HEART;
            }

            getBaseStrength() {
                if (this.isJoker) return 0;
                return RANK_VALUES[this.rank];
            }

            getDealmeeScore(mighty) {
                if (this.isJoker) return -1;
                if (this.equals(mighty)) return 0;
                if (this.rank === '10') return 0.5;
                if (POINT_RANKS.includes(this.rank) && this.rank !== '10') return 1;
                return 0;
            }
        }

        class Deck {
            constructor() {
                this.cards = [];
                this.initialize();
            }

            initialize() {
                this.cards = [];
                for (const suit of Object.values(SUITS)) {
                    for (const rank of RANKS) {
                        this.cards.push(new Card(suit, rank));
                    }
                }
                this.cards.push(Card.createJoker());
            }

            shuffle() {
                for (let i = this.cards.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [this.cards[i], this.cards[j]] = [this.cards[j], this.cards[i]];
                }
            }

            deal(count) {
                return this.cards.splice(0, count);
            }
        }

        // ===== 유틸리티 함수 =====

        function getMighty(giruda) {
            if (giruda === SUITS.SPADE) return new Card(SUITS.DIAMOND, 'A');
            return new Card(SUITS.SPADE, 'A');
        }

        function getJokerCall(giruda) {
            if (giruda === SUITS.CLUB) return new Card(SUITS.SPADE, '3');
            return new Card(SUITS.CLUB, '3');
        }

        function sortCards(cards, giruda = null, mighty = null) {
            const redSuits = [SUITS.DIAMOND, SUITS.HEART];
            const blackSuits = [SUITS.SPADE, SUITS.CLUB];
            let suitOrder;
            if (giruda) {
                const isGirudaRed = redSuits.includes(giruda);
                if (isGirudaRed) {
                    const otherRed = redSuits.find(s => s !== giruda);
                    suitOrder = [giruda, SUITS.SPADE, otherRed, SUITS.CLUB];
                } else {
                    const otherBlack = blackSuits.find(s => s !== giruda);
                    suitOrder = [giruda, SUITS.DIAMOND, otherBlack, SUITS.HEART];
                }
            } else {
                suitOrder = [SUITS.SPADE, SUITS.DIAMOND, SUITS.CLUB, SUITS.HEART];
            }
            return [...cards].sort((a, b) => {
                const aIsMighty = mighty && a.equals(mighty);
                const bIsMighty = mighty && b.equals(mighty);
                if (aIsMighty && !bIsMighty) return -1;
                if (!aIsMighty && bIsMighty) return 1;
                if (a.isJoker && !b.isJoker) return -1;
                if (!a.isJoker && b.isJoker) return 1;
                if (a.isJoker && b.isJoker) return 0;
                const suitDiff = suitOrder.indexOf(a.suit) - suitOrder.indexOf(b.suit);
                if (suitDiff !== 0) return suitDiff;
                return RANK_VALUES[b.rank] - RANK_VALUES[a.rank];
            });
        }

        function findCard(hand, card) {
            return hand.find(c => c.equals(card));
        }

        function hasCard(hand, card) {
            return hand.some(c => c.equals(card));
        }

        function getCardsOfSuit(hand, suit) {
            return hand.filter(c => !c.isJoker && c.suit === suit);
        }

        function countPoints(cards) {
            return cards.filter(c => c.isPointCard()).length;
        }

        function calculateDealmeeScore(hand, mighty) {
            return hand.reduce((sum, card) => sum + card.getDealmeeScore(mighty), 0);
        }

        function checkPoolRequestEligibility(hand, mighty) {
            const hasMighty = hand.some(c => c.equals(mighty));
            const hasJoker = hand.some(c => c.isJoker);
            const pointCardCount = hand.filter(c => {
                if (c.isJoker) return false;
                if (c.equals(mighty)) return false;
                return POINT_RANKS.includes(c.rank);
            }).length;
            if (hasMighty && pointCardCount === 0) {
                return { eligible: true, reason: '마이티 보유, 점수카드 없음', hasMighty: true, hasJoker: false, pointCardCount: 0 };
            }
            if (hasJoker && pointCardCount <= 1) {
                return { eligible: true, reason: pointCardCount === 0 ? '조커 보유, 점수카드 없음' : '조커 보유, 점수카드 1장', hasMighty: false, hasJoker: true, pointCardCount };
            }
            if (pointCardCount === 0 && !hasMighty && !hasJoker) {
                return { eligible: true, reason: '점수카드 없음 (그림카드 전무)', hasMighty: false, hasJoker: false, pointCardCount: 0 };
            }
            return { eligible: false, reason: null, hasMighty, hasJoker, pointCardCount };
        }


        function getPlayableCards(hand, leadSuit, round, gameContext) {
            if (!leadSuit) {
                let playable = [...hand];

                // 초구(1라운드)에서는 조커 리드 불가
                if (round === 1) {
                    const nonJoker = playable.filter(c => !c.isJoker);
                    if (nonJoker.length > 0) playable = nonJoker;
                }

                // 초구 주공 기루다 리드 제한
                if (gameContext.isFirstRoundLead && gameContext.giruda) {
                    const nonGirudaCards = playable.filter(c => !c.isJoker && c.suit !== gameContext.giruda);
                    if (nonGirudaCards.length > 0) playable = nonGirudaCards;
                }

                return playable;
            }


            const { mighty, jokerCalled, mightyPlayedInTrick } = gameContext;
            const joker = hand.find(c => c.isJoker);
            const mightyCard = findCard(hand, mighty);
            if (jokerCalled) {
                if (joker) {
                    if (mightyCard) return [joker, mightyCard];
                    return [joker];
                }
            }
            const leadSuitCards = getCardsOfSuit(hand, leadSuit);
            if (leadSuitCards.length > 0) {
                const playableCards = [...leadSuitCards];
                if (mightyCard && !leadSuitCards.some(c => c.equals(mighty))) {
                    playableCards.push(mightyCard);
                }
                if (joker && round >= 2 && round <= 9 && !mightyPlayedInTrick) {
                    playableCards.push(joker);
                }
                return playableCards;
            }
            if (mightyPlayedInTrick) return hand.filter(c => !c.isJoker);
            return [...hand];
        }

        // ========================================
        // ===== player.js =====
        // ========================================

        class Player {
            constructor(index, name, isHuman = false) {
                this.index = index;
                this.name = name;
                this.isHuman = isHuman;
                this.hand = [];
                this.scoreCards = [];
                this.role = ROLES.UNKNOWN;
                this.totalScore = 0;
                this.hasPassed = false;
            }

            reset() {
                this.hand = [];
                this.scoreCards = [];
                this.role = ROLES.UNKNOWN;
                this.hasPassed = false;
            }

            receiveCards(cards) { this.hand.push(...cards); }

            sortHand(giruda = null, mighty = null) {
                this.hand = sortCards(this.hand, giruda, mighty);
            }

            playCard(card) {
                const index = this.hand.findIndex(c => c.equals(card));
                if (index !== -1) return this.hand.splice(index, 1)[0];
                return null;
            }

            addScoreCards(cards) {
                const points = cards.filter(c => c.isPointCard());
                this.scoreCards.push(...points);
            }

            getScore() { return this.scoreCards.length; }
            hasCard(card) { return hasCard(this.hand, card); }
            hasSuit(suit) { return this.hand.some(c => !c.isJoker && c.suit === suit); }
            setRole(role) { this.role = role; }

            getRoleText() {
                switch (this.role) {
                    case ROLES.MASTER: return '주공';
                    case ROLES.FRIEND: return '친구';
                    case ROLES.OPPOSITION: return '야당';
                    default: return '';
                }
            }
        }
    </script>
    <script>
        // ========================================
        // ===== gameState.js =====
        // ========================================

        class GameState {
            constructor() {
                this.reset();
            }

            reset() {
                if (this.players && this.players.length === 5) {
                    const savedScores = this.players.map(p => p.totalScore);
                    this.players.forEach((p, i) => {
                        p.reset();
                        p.totalScore = savedScores[i];
                    });
                } else {
                    this.players = [
                        new Player(0, '나', true),
                        new Player(1, 'AI-1', false),
                        new Player(2, 'AI-2', false),
                        new Player(3, 'AI-3', false),
                        new Player(4, 'AI-4', false)
                    ];
                }

                this.phase = PHASES.WAITING;
                this.round = 0;
                this.dealer = Math.floor(Math.random() * 5);
                this.currentTurn = 0;

                this.bidding = {
                    currentBid: null,
                    history: [],
                    passedPlayers: []
                };

                this.contract = {
                    master: null,
                    friend: null,
                    friendCard: null,
                    bidValue: 0,
                    giruda: null,
                    mighty: null,
                    jokerCall: null,
                    isNoFriend: false,
                    isNoGiruda: false,
                    isSolino: false,
                    friendRevealed: false
                };

                this.trick = {
                    cards: [],
                    leadPlayer: null,
                    leadSuit: null,
                    jokerCalled: false,
                    jokerCallSuit: null
                };

                this.floorCards = [];
                this.governmentScore = 0;
                this.oppositionScore = 0;
                this.mightyUsed = false;
                this.jokerUsed = false;
                this.friendRevealed = false;
                this.playedCards = [];
                this.playerVoidSuits = new Map();
                this.cardTracker = this.initializeCardTracker();
                this.aiLogs = [];
                this.dealmeePool = 0;
                this.poolRequester = null;
                this.sayeonResponse = null;

                this.friendContribution = {
                    tricksWon: 0,
                    pointsSecured: 0,
                    mightyUsed: false,
                    jokerUsed: false
                };
            }

            getNextPlayer(current) {
                return (current + 1) % GAME_CONFIG.PLAYER_COUNT;
            }

            getFirstBidder() {
                return this.getNextPlayer(this.dealer);
            }

            isValidBid(value, suit) {
                if (value < GAME_CONFIG.MIN_BID || value > GAME_CONFIG.MAX_BID) return false;
                if (!this.bidding.currentBid) return true;
                const currentValue = this.bidding.currentBid.value;
                const currentSuit = this.bidding.currentBid.suit;
                if (value > currentValue) return true;
                if (value === currentValue) {
                    return SUIT_STRENGTH[suit] > SUIT_STRENGTH[currentSuit];
                }
                return false;
            }

            recordBid(playerIndex, value, suit) {
                this.bidding.currentBid = { player: playerIndex, value, suit };
                this.bidding.history.push({ player: playerIndex, value, suit, type: 'bid' });
            }

            recordPass(playerIndex) {
                this.bidding.passedPlayers.push(playerIndex);
                this.bidding.history.push({ player: playerIndex, type: 'pass' });
                this.players[playerIndex].hasPassed = true;
            }

            isBiddingComplete() {
                if (this.bidding.passedPlayers.length === GAME_CONFIG.PLAYER_COUNT) return true;
                const activeBidders = [];
                for (let i = 0; i < GAME_CONFIG.PLAYER_COUNT; i++) {
                    if (!this.bidding.passedPlayers.includes(i)) activeBidders.push(i);
                }
                return activeBidders.length === 1 && this.bidding.currentBid !== null;
            }

            determineMaster() {
                if (this.bidding.currentBid) return this.bidding.currentBid.player;
                return null;
            }

            // ★ 개선: 노기루다 시 giruda를 null로 통일
            setupContract() {
                const master = this.determineMaster();
                if (master === null) return false;

                this.contract.master = master;
                this.contract.bidValue = this.bidding.currentBid.value;

                const bidSuit = this.bidding.currentBid.suit;
                this.contract.isNoGiruda = (bidSuit === 'none');
                this.contract.giruda = this.contract.isNoGiruda ? null : bidSuit;

                this.contract.mighty = getMighty(this.contract.giruda);
                this.contract.jokerCall = getJokerCall(this.contract.giruda);
                this.players[master].setRole(ROLES.MASTER);
                return true;
            }

            // ★ 개선: 친구 카드가 바닥에 있는 경우 처리
            setFriend(friendCard) {
                this.contract.friendCard = friendCard;

                if (this.contract.isSolino) {
                    this.contract.isNoFriend = true;
                    this.contract.friendCard = null;
                    this.players.forEach((player, idx) => {
                        if (idx !== this.contract.master) player.setRole(ROLES.OPPOSITION);
                    });
                    return;
                }

                if (!friendCard) {
                    this.contract.isNoFriend = true;
                    this.players.forEach((player, idx) => {
                        if (idx !== this.contract.master) player.setRole(ROLES.OPPOSITION);
                    });
                    return;
                }

                // 주공이 친구 카드를 가진 경우
                if (this.players[this.contract.master].hasCard(friendCard)) {
                    this.contract.isNoFriend = true;
                    this.contract.friend = null;
                }
                // ★ 바닥에 버려진 경우도 노프렌드
                else if (this.floorCards.some(c => c.equals(friendCard))) {
                    this.contract.isNoFriend = true;
                    this.contract.friend = null;
                } else {
                    // 친구 카드 소유자 찾기
                    for (let i = 0; i < GAME_CONFIG.PLAYER_COUNT; i++) {
                        if (i === this.contract.master) continue;
                        if (this.players[i].hasCard(friendCard)) {
                            this.contract.friend = i;
                            this.players[i].setRole(ROLES.FRIEND);
                            break;
                        }
                    }
                }

                // 나머지는 야당
                this.players.forEach((player, idx) => {
                    if (player.role === ROLES.UNKNOWN) player.setRole(ROLES.OPPOSITION);
                });
            }

            revealFriend(playerIndex) {
                if (!this.friendRevealed && this.contract.friend === playerIndex) {
                    this.friendRevealed = true;
                    this.contract.friendRevealed = true;
                    return true;
                }
                return false;
            }

            startTrick(leadPlayer) {
                this.trick = {
                    cards: [],
                    leadPlayer,
                    leadSuit: null,
                    jokerCalled: false,
                    jokerCallSuit: null
                };
                this.currentTurn = leadPlayer;
            }

            playCardToTrick(playerIndex, card, jokerCallSuit = null) {
                this.trick.cards.push({ player: playerIndex, card });

                if (this.trick.cards.length === 1) {
                    if (card.isJoker) {
                        this.trick.leadSuit = jokerCallSuit;
                        this.trick.jokerCallSuit = jokerCallSuit;
                    } else {
                        this.trick.leadSuit = card.suit;
                    }
                    if (card.equals(this.contract.jokerCall) && this.round > 1 && this.round < 10 && !this.jokerUsed) {

                        this.trick.jokerCalled = true;
                    }
                }

                if (card.equals(this.contract.mighty)) this.mightyUsed = true;
                if (card.isJoker) this.jokerUsed = true;

                if (this.contract.friendCard && card.equals(this.contract.friendCard)) {
                    this.revealFriend(playerIndex);
                }

                this.playedCards.push(card);

                if (!card.isJoker && card.suit !== this.trick.leadSuit) {
                    if (!this.playerVoidSuits.has(playerIndex)) {
                        this.playerVoidSuits.set(playerIndex, new Set());
                    }
                    this.playerVoidSuits.get(playerIndex).add(this.trick.leadSuit);
                }

                this.updateCardTracker(playerIndex, card, this.trick.leadSuit);
                this.currentTurn = this.getNextPlayer(playerIndex);
                const events = this.detectPlayEvents(playerIndex, card);
                for (const evt of events) {
                    eventBus.emit(evt.type, evt.data);
                }
            }

            determineTrickWinner() {
                const { mighty, giruda } = this.contract;
                const leadSuit = this.trick.leadSuit;
                const round = this.round;
                const isNoGiruda = this.contract.isNoGiruda;

                let winner = null;
                let winningCard = null;
                let highestValue = -1;

                for (const play of this.trick.cards) {
                    const card = play.card;
                    let priority = 0;
                    let cardValue = 0;

                    if (card.equals(mighty)) {
                        priority = 1000;
                        cardValue = 100;
                    } else if (card.isJoker && round >= 2 && round <= 9 && !this.trick.jokerCalled) {
                        priority = 900;
                        cardValue = 90;
                    } else if (card.isJoker) {
                        priority = 0;
                        cardValue = 0;
                    } else if (!isNoGiruda && giruda && card.suit === giruda) {
                        priority = 500;
                        cardValue = RANK_VALUES[card.rank];
                    } else if (card.suit === leadSuit) {
                        priority = 100;
                        cardValue = RANK_VALUES[card.rank];
                    } else {
                        priority = 0;
                        cardValue = 0;
                    }

                    const totalValue = priority + cardValue;
                    if (totalValue > highestValue) {
                        highestValue = totalValue;
                        winner = play.player;
                        winningCard = card;
                    }
                }

                return { winner, winningCard };
            }

            endTrick() {
                const { winner, winningCard } = this.determineTrickWinner();
                const trickCards = this.trick.cards.map(p => p.card);
                const trickPoints = trickCards.filter(c => c.isPointCard()).length;

                if (winner === this.contract.friend) {
                    this.friendContribution.tricksWon++;
                    this.friendContribution.pointsSecured += trickPoints;
                    if (winningCard) {
                        if (winningCard.equals(this.contract.mighty)) this.friendContribution.mightyUsed = true;
                        if (winningCard.isJoker) this.friendContribution.jokerUsed = true;
                    }
                }

                this.players[winner].addScoreCards(trickCards);
                this.updateTeamScores();
                return winner;
            }

            updateTeamScores() {
                this.governmentScore = 0;
                this.oppositionScore = 0;
                for (const player of this.players) {
                    const score = player.getScore();
                    if (player.role === ROLES.MASTER || player.role === ROLES.FRIEND) {
                        this.governmentScore += score;
                    } else {
                        this.oppositionScore += score;
                    }
                }
            }

            isGovernmentWinning() {
                return this.governmentScore >= this.contract.bidValue;
            }

            isBackrun() {
                return this.oppositionScore === GAME_CONFIG.TOTAL_POINTS;
            }

            calculateFinalScores() {
                const bidValue = this.contract.bidValue;
                const govScore = this.governmentScore;
                const multiplier = this.contract.isNoGiruda ? 2 : 1;
                let results = [];

                if (this.isBackrun()) {
                    const penalty = 20 * multiplier;
                    for (const player of this.players) {
                        if (player.role === ROLES.MASTER) {
                            results.push({ player: player.index, change: -penalty * 2 });
                        } else if (player.role === ROLES.FRIEND) {
                            results.push({ player: player.index, change: -penalty });
                        } else {
                            results.push({ player: player.index, change: penalty });
                        }
                    }
                    return { winner: 'opposition', isBackrun: true, results };
                }

                const govWins = govScore >= bidValue;
                let baseScore;
                if (govWins) {
                    baseScore = (govScore - 10) * multiplier;
                } else {
                    baseScore = (bidValue - govScore) * multiplier;
                }

                if (this.contract.isNoFriend) {
                    for (const player of this.players) {
                        if (player.role === ROLES.MASTER) {
                            results.push({ player: player.index, change: govWins ? baseScore * 4 : -baseScore * 4 });
                        } else {
                            results.push({ player: player.index, change: govWins ? -baseScore : baseScore });
                        }
                    }
                } else {
                    for (const player of this.players) {
                        if (player.role === ROLES.MASTER) {
                            results.push({ player: player.index, change: govWins ? baseScore * 2 : -baseScore * 2 });
                        } else if (player.role === ROLES.FRIEND) {
                            results.push({ player: player.index, change: govWins ? baseScore : -baseScore });
                        } else {
                            results.push({ player: player.index, change: govWins ? -baseScore : baseScore });
                        }
                    }
                }

                if (this.dealmeePool > 0 && govWins) {
                    const masterResult = results.find(r => r.player === this.contract.master);
                    if (masterResult) masterResult.change += this.dealmeePool;
                }

                return { winner: govWins ? 'government' : 'opposition', isBackrun: false, results };
            }

            addAILog(log) {
                this.aiLogs.push(log);
                if (this.aiLogs.length > 50) this.aiLogs.shift();
            }

            getTeamContext(playerIndex) {
                const player = this.players[playerIndex];
                return {
                    myRole: player.role,
                    isFriendRevealed: this.friendRevealed,
                    masterIndex: this.contract.master,
                    friendIndex: this.contract.friend,
                    governmentPlayers: this.players
                        .filter(p => p.role === ROLES.MASTER || p.role === ROLES.FRIEND)
                        .map(p => p.index),
                    oppositionPlayers: this.players
                        .filter(p => p.role === ROLES.OPPOSITION)
                        .map(p => p.index)
                };
            }

            // ★ 개선: analyzeTrick - cardsToWin 및 remainingPlayers 계산 수정
            analyzeTrick(playerIndex) {
                const player = this.players[playerIndex];
                const hand = player.hand;
                const teamContext = this.getTeamContext(playerIndex);

                const mightyPlayedInTrick = this.trick.cards.some(
                    p => p.card.equals(this.contract.mighty)
                );

                const isFirstRoundLead = (this.round === 1
                    && this.trick.cards.length === 0
                    && playerIndex === this.contract.master);

                const playableCards = getPlayableCards(hand, this.trick.leadSuit, this.round, {
                    mighty: this.contract.mighty,
                    jokerCalled: this.trick.jokerCalled,
                    mightyPlayedInTrick,
                    isFirstRoundLead,
                    giruda: this.contract.giruda
                });


                let currentWinner = null;
                let isGovernmentWinning = false;
                let isOppositionWinning = false;
                let isUncertain = false;

                if (this.trick.cards.length > 0) {
                    const { winner } = this.determineTrickWinner();
                    currentWinner = winner;
                    if (teamContext.governmentPlayers.includes(winner)) {
                        isGovernmentWinning = true;
                    } else if (teamContext.oppositionPlayers.includes(winner)) {
                        isOppositionWinning = true;
                    } else {
                        isUncertain = true;
                    }
                }

                // ★ 개선된 cardsToWin 계산
                const cardsToWin = playableCards.filter(card => {
                    if (this.trick.cards.length === 0) return true;
                    if (card.equals(this.contract.mighty)) return true;
                    if (card.isJoker && this.round >= 2 && this.round <= 9 && !this.trick.jokerCalled) {
                        return !mightyPlayedInTrick;
                    }
                    if (card.isJoker) return false;

                    const { winningCard } = this.determineTrickWinner();
                    if (!winningCard) return true;
                    if (winningCard.equals(this.contract.mighty)) return false;
                    if (winningCard.isJoker && !this.trick.jokerCalled) return false;

                    const giruda = this.contract.giruda;
                    const isNoGiruda = this.contract.isNoGiruda;
                    const leadSuit = this.trick.leadSuit;

                    if (winningCard.isJoker) return true; // jokerCalled로 무효화된 조커

                    const winSuit = winningCard.suit;
                    const winValue = RANK_VALUES[winningCard.rank];

                    // 이기고 있는 카드가 기루다인 경우
                    if (!isNoGiruda && giruda && winSuit === giruda) {
                        if (card.suit === giruda) return RANK_VALUES[card.rank] > winValue;
                        return false;
                    }

                    // 이기고 있는 카드가 리드 수트인 경우
                    if (winSuit === leadSuit) {
                        if (!isNoGiruda && giruda && card.suit === giruda) return true;
                        if (card.suit === leadSuit) return RANK_VALUES[card.rank] > winValue;
                        return false;
                    }

                    // 그 외
                    if (!isNoGiruda && giruda && card.suit === giruda) return true;
                    if (card.suit === leadSuit) return true;
                    return false;
                });

                const pointsInTrick = this.trick.cards.reduce((sum, p) => {
                    return sum + (p.card.isPointCard() ? 1 : 0);
                }, 0);

                // ★ 개선된 remainingPlayers 계산
                const playedPlayers = new Set(this.trick.cards.map(p => p.player));
                playedPlayers.add(playerIndex);

                const remainingPlayers = [];
                let checkPlayer = this.getNextPlayer(playerIndex);
                let safety = 0;
                while (safety < GAME_CONFIG.PLAYER_COUNT) {
                    if (playedPlayers.has(checkPlayer)) {
                        checkPlayer = this.getNextPlayer(checkPlayer);
                        safety++;
                        continue;
                    }
                    if (this.trick.cards.length > 0 && checkPlayer === this.trick.leadPlayer) break;
                    remainingPlayers.push(checkPlayer);
                    playedPlayers.add(checkPlayer);
                    checkPlayer = this.getNextPlayer(checkPlayer);
                    safety++;
                }

                return {
                    leadSuit: this.trick.leadSuit,
                    currentWinner,
                    isGovernmentWinning,
                    isOppositionWinning,
                    isUncertain,
                    playableCards,
                    canWin: cardsToWin.length > 0,
                    cardsToWin,
                    pointsInTrick,
                    remainingPlayers,
                    hasGovernmentRemaining: remainingPlayers.some(p => teamContext.governmentPlayers.includes(p)),
                    hasOppositionRemaining: remainingPlayers.some(p => teamContext.oppositionPlayers.includes(p))
                };
            }

            // ===== 카드 추적 시스템 =====
            initializeCardTracker() {
                const allCards = [];
                for (const suit of Object.values(SUITS)) {
                    for (const rank of RANKS) allCards.push(new Card(suit, rank));
                }
                allCards.push(Card.createJoker());
                const allPointCards = allCards.filter(c => c.isPointCard());
                return {
                    allCards,
                    playedCards: [],
                    remainingCards: [...allCards],
                    playedPointCards: [],
                    remainingPointCards: [...allPointCards],
                    playerVoidSuits: new Map(),
                    mightyPlayed: false,
                    jokerPlayed: false
                };
            }

            updateCardTracker(playerIndex, card, leadSuit) {
                const tracker = this.cardTracker;
                tracker.playedCards.push({ player: playerIndex, card });
                tracker.remainingCards = tracker.remainingCards.filter(c => !c.equals(card));
                if (card.isPointCard()) {
                    tracker.playedPointCards.push(card);
                    tracker.remainingPointCards = tracker.remainingPointCards.filter(c => !c.equals(card));
                }
                if (this.contract.mighty && card.equals(this.contract.mighty)) tracker.mightyPlayed = true;
                if (card.isJoker) tracker.jokerPlayed = true;
                if (leadSuit && !card.isJoker && card.suit !== leadSuit) {
                    if (!tracker.playerVoidSuits.has(playerIndex)) tracker.playerVoidSuits.set(playerIndex, new Set());
                    tracker.playerVoidSuits.get(playerIndex).add(leadSuit);
                }
            }

            detectPlayEvents(playerIndex, card) {
    const events = [];
    const mighty = this.contract.mighty;
    const giruda = this.contract.giruda;
    const trickCards = this.trick.cards;
    const round = this.round;

    // 마이티 등장
    if (mighty && card.equals(mighty)) {
        events.push({ type: 'mighty-played', data: { player: playerIndex, card } });
    }

    // 조커 등장
    if (card.isJoker && round >= 2 && round <= 9) {
        events.push({ type: 'joker-played', data: { player: playerIndex, card } });
    }

    // 조커콜 발동
    if (trickCards.length === 1 && this.trick.jokerCalled) {
        events.push({ type: 'joker-called', data: { player: playerIndex, card } });
    }

    // 친구 카드 공개
    if (this.contract.friendCard && card.equals(this.contract.friendCard) && !this.friendRevealed) {
        // friendRevealed는 이미 revealFriend에서 true로 설정됨
        events.push({ type: 'friend-revealed', data: { player: playerIndex, card } });
    }

    // 기루다 컷 / 오버컷 감지
    if (trickCards.length >= 2 && !card.isJoker && !card.equals(mighty)) {
        const leadSuit = this.trick.leadSuit;

        // 이전 승자 찾기
        const prevCards = trickCards.slice(0, -1);
        let prevWinner = null;
        let prevWinCard = null;
        if (prevCards.length > 0) {
            // 간이 승자 판정
            for (const p of prevCards) {
                if (!prevWinner || this.compareCards(p.card, prevWinCard, leadSuit) > 0) {
                    prevWinner = p.player;
                    prevWinCard = p.card;
                }
            }
        }

        if (prevWinCard && giruda && card.suit === giruda && leadSuit !== giruda) {
            // 기루다 컷!
            if (prevWinCard.suit === giruda) {
                // 오버컷 (이전 승자도 기루다였는데 더 높은 기루다)
                if (RANK_VALUES[card.rank] > RANK_VALUES[prevWinCard.rank]) {
                    events.push({
                        type: 'over-cut',
                        data: { player: playerIndex, card, prevWinner, prevCard: prevWinCard }
                    });
                }
            } else {
                events.push({
                    type: 'giruda-cut',
                    data: { player: playerIndex, card, prevWinner, prevCard: prevWinCard }
                });
            }
        }

        // 마이티로 조커 격파
        if (card.equals(mighty) && prevWinCard && prevWinCard.isJoker) {
            events.push({
                type: 'mighty-beats-joker',
                data: { player: playerIndex, card, prevCard: prevWinCard }
            });
        }
    }

    return events;
}

compareCards(cardA, cardB, leadSuit) {
    const mighty = this.contract.mighty;
    const giruda = this.contract.giruda;

    const scoreCard = (c) => {
        if (c.equals(mighty)) return 10000;
        if (c.isJoker) return 9000;
        let base = RANK_VALUES[c.rank];
        if (giruda && c.suit === giruda) base += 5000;
        else if (c.suit === leadSuit) base += 1000;
        return base;
    };

    return scoreCard(cardA) - scoreCard(cardB);
}

            doesPlayerHaveSuit(playerIndex, suit) {
                const voidSuits = this.cardTracker.playerVoidSuits.get(playerIndex);
                if (voidSuits && voidSuits.has(suit)) return false;
                return null;
            }

            getRemainingPointCount() { return this.cardTracker.remainingPointCards.length; }

            getRemainingCardsOfSuit(suit) {
                return this.cardTracker.remainingCards.filter(c => !c.isJoker && c.suit === suit);
            }

            isMightyStillInPlay() { return !this.cardTracker.mightyPlayed; }
            isJokerStillInPlay() { return !this.cardTracker.jokerPlayed; }

            isCardStillInPlay(card) {
                return this.cardTracker.remainingCards.some(c => c.equals(card));
            }

            isBossCard(card) {
                if (!card || card.isJoker) return false;
                const suit = card.suit;
                const cardStrength = RANK_VALUES[card.rank];
                const remainingHigherCards = this.cardTracker.remainingCards.filter(c => {
                    if (c.isJoker) return false;
                    if (c.suit !== suit) return false;
                    if (c.equals(card)) return false;
                    return RANK_VALUES[c.rank] > cardStrength;
                });
                return remainingHigherCards.length === 0;
            }

            getBossCardOfSuit(suit) {
                const remainingCards = this.cardTracker.remainingCards.filter(c => !c.isJoker && c.suit === suit);
                if (remainingCards.length === 0) return null;
                remainingCards.sort((a, b) => RANK_VALUES[b.rank] - RANK_VALUES[a.rank]);
                return remainingCards[0];
            }

            getGirudaBossCard() {
                if (!this.contract.giruda) return null;
                return this.getBossCardOfSuit(this.contract.giruda);
            }

            getCardAnalysis(card) {
                if (!card || card.isJoker) {
                    return { card, isBoss: false, isGirudaBoss: false, higherCardsRemaining: 0 };
                }
                const suit = card.suit;
                const cardStrength = RANK_VALUES[card.rank];
                const giruda = this.contract.giruda;
                const mighty = this.contract.mighty;

                // ★ 마이티는 별도 처리 (항상 보스카드)
                if (mighty && card.equals(mighty)) {
                    return { card, isBoss: true, isGirudaBoss: false, higherCardsRemaining: 0 };
                }

                // ★ 남은 카드 중 같은 수트의 더 높은 카드 수 계산
                // (마이티는 특수카드이므로 일반 수트 비교에서 제외)
                const higherCardsRemaining = this.cardTracker.remainingCards.filter(c => {
                    if (c.isJoker) return false;
                    if (c.suit !== suit) return false;
                    if (c.equals(card)) return false;
                    // ★ 마이티는 수트 비교에서 제외 (마이티는 모든 카드를 이기지만 수트 보스 판정과 무관)
                    if (mighty && c.equals(mighty)) return false;
                    return RANK_VALUES[c.rank] > cardStrength;
                }).length;

                const isBoss = higherCardsRemaining === 0;
                const isGirudaBoss = isBoss && suit === giruda;
                return { card, isBoss, isGirudaBoss, higherCardsRemaining };
            }


            estimatePlayerPossibleCards(playerIndex, myHand) {
                const tracker = this.cardTracker;
                const voidSuits = tracker.playerVoidSuits.get(playerIndex) || new Set();
                return tracker.remainingCards.filter(card => {
                    if (myHand.some(c => c.equals(card))) return false;
                    if (!card.isJoker && voidSuits.has(card.suit)) return false;
                    return true;
                });
            }

            estimateMightyHolder(myIndex, myHand) {
                if (this.cardTracker.mightyPlayed) return { holder: -1, probability: 0 };
                const mighty = this.contract.mighty;
                if (hasCard(myHand, mighty)) return { holder: myIndex, probability: 1 };
                const possibleHolders = [];
                for (let i = 0; i < GAME_CONFIG.PLAYER_COUNT; i++) {
                    if (i === myIndex) continue;
                    const voidSuits = this.cardTracker.playerVoidSuits.get(i);
                    if (voidSuits && voidSuits.has(mighty.suit)) continue;
                    possibleHolders.push(i);
                }
                if (possibleHolders.length === 0) return { holder: -1, probability: 0 };
                return { holders: possibleHolders, probability: 1 / possibleHolders.length };
            }

            estimateJokerHolder(myIndex, myHand) {
                if (this.cardTracker.jokerPlayed) return { holder: -1, probability: 0 };
                if (myHand.some(c => c.isJoker)) return { holder: myIndex, probability: 1 };
                const possibleHolders = [];
                for (let i = 0; i < GAME_CONFIG.PLAYER_COUNT; i++) {
                    if (i !== myIndex) possibleHolders.push(i);
                }
                return { holders: possibleHolders, probability: 1 / possibleHolders.length };
            }

            getCardTrackingSummary(myIndex, myHand) {
                return {
                    totalPlayed: this.cardTracker.playedCards.length,
                    remainingCount: this.cardTracker.remainingCards.length,
                    pointsPlayed: this.cardTracker.playedPointCards.length,
                    pointsRemaining: this.cardTracker.remainingPointCards.length,
                    mightyPlayed: this.cardTracker.mightyPlayed,
                    jokerPlayed: this.cardTracker.jokerPlayed,
                    mightyHolder: this.estimateMightyHolder(myIndex, myHand),
                    jokerHolder: this.estimateJokerHolder(myIndex, myHand),
                    playerVoidSuits: Object.fromEntries(
                        Array.from(this.cardTracker.playerVoidSuits.entries()).map(
                            ([k, v]) => [k, Array.from(v)]
                        )
                    )
                };
            }
            // ★ 여당 승리 가능성 판단
            

            // ★ 게임 저장
            serialize() {
                try {
                    return JSON.stringify({
                        players: this.players.map(p => ({
                            index: p.index, name: p.name,
                            hand: p.hand.map(c => c.isJoker ? { isJoker: true } : { suit: c.suit, rank: c.rank }),
                            scoreCards: p.scoreCards.map(c => ({ suit: c.suit, rank: c.rank })),
                            role: p.role, totalScore: p.totalScore, hasPassed: p.hasPassed
                        })),
                        phase: this.phase, round: this.round, dealer: this.dealer,
                        currentTurn: this.currentTurn,
                        governmentScore: this.governmentScore, oppositionScore: this.oppositionScore,
                        mightyUsed: this.mightyUsed, jokerUsed: this.jokerUsed,
                        friendRevealed: this.friendRevealed, dealmeePool: this.dealmeePool
                    });
                } catch (e) { return null; }
            }

            saveToLocal() {
                try { localStorage.setItem('mighty_game_save', this.serialize()); return true; }
                catch (e) { return false; }
            }
        }

        // ========================================
        // ===== ai.js =====
        // ========================================

        class AI {
            constructor(gameState, settings) {
                this.gameState = gameState;
                this.settings = settings;
            }

            // ===== 비딩 AI =====
            decideBid(playerIndex) {
                const player = this.gameState.players[playerIndex];
                const hand = player.hand;
                const currentBid = this.gameState.bidding.currentBid;
                const evaluation = this.evaluateHand(hand);
                const reasoning = [];

                reasoning.push(`손패 평가 점수: ${evaluation.totalScore.toFixed(1)}`);

                if (evaluation.shouldPass) {
                    reasoning.push('패가 약하여 패스');
                    return { action: 'pass', reasoning };
                }

                if (!currentBid) {
                    const suitName = evaluation.recommendedGiruda === 'none' ? '노기루다' :
                        (SUIT_NAMES[evaluation.recommendedGiruda] || '스페이드');
                    reasoning.push(`추천 기루다: ${suitName}`);
                    return {
                        action: 'bid',
                        value: 13,
                        suit: evaluation.recommendedGiruda || SUITS.SPADE,
                        reasoning
                    };
                }

                const myMaxBid = evaluation.recommendedBid;
                if (myMaxBid < currentBid.value) {
                    reasoning.push(`최대 가능 비딩(${myMaxBid})이 현재 비딩(${currentBid.value})보다 낮음`);
                    return { action: 'pass', reasoning };
                }

                let bidValue = currentBid.value;
                let bidSuit = evaluation.recommendedGiruda || SUITS.SPADE;

                if (this.gameState.isValidBid(bidValue, bidSuit)) {
                    const sym = bidSuit === 'none' ? 'No' : SUIT_SYMBOLS[bidSuit];
                    reasoning.push(`${bidValue}${sym} 비딩`);
                    return { action: 'bid', value: bidValue, suit: bidSuit, reasoning };
                }

                bidValue = currentBid.value + 1;
                if (bidValue <= GAME_CONFIG.MAX_BID && bidValue <= myMaxBid) {
                    const sym = bidSuit === 'none' ? 'No' : SUIT_SYMBOLS[bidSuit];
                    reasoning.push(`${bidValue}${sym} 비딩`);
                    return { action: 'bid', value: bidValue, suit: bidSuit, reasoning };
                }

                reasoning.push('더 높은 비딩 불가, 패스');
                return { action: 'pass', reasoning };
            }

            // ★ 개선: 노기루다 비딩 포함
            // ★ 전면 개선: 손패 평가
            evaluateHand(hand) {
                const baseMighty = new Card(SUITS.SPADE, 'A');
                const hasMighty = hasCard(hand, baseMighty);
                const hasJoker = hand.some(c => c.isJoker);

                const suitCounts = {};
                const suitStrengths = {};

                for (const suit of Object.values(SUITS)) {
                    const suitCards = getCardsOfSuit(hand, suit);
                    suitCounts[suit] = suitCards.length;

                    let strength = 0;
                    if (suitCards.some(c => c.rank === 'A')) strength += 2.5;
                    if (suitCards.some(c => c.rank === 'K')) strength += 1.5;
                    if (suitCards.some(c => c.rank === 'Q')) strength += 0.8;
                    if (suitCards.some(c => c.rank === 'J')) strength += 0.3;
                    if (suitCards.length >= 4) strength += (suitCards.length - 3) * 1.0;
                    if (suitCards.length >= 6) strength += 1.0;

                    suitStrengths[suit] = strength;
                }

                let bestSuit = null;
                let bestStrength = 0;
                for (const suit of Object.values(SUITS)) {
                    if (suitCounts[suit] >= 3 && suitStrengths[suit] > bestStrength) {
                        bestStrength = suitStrengths[suit];
                        bestSuit = suit;
                    }
                }

                // ★★★ 기루다 있을 때 예상 트릭 수 계산 ★★★
                let estimatedTricks = 0;

                if (hasMighty) estimatedTricks += 1.0;
                if (hasJoker) estimatedTricks += 0.8;

                if (bestSuit) {
                    const girudaCards = getCardsOfSuit(hand, bestSuit);
                    if (girudaCards.some(c => c.rank === 'A' && !c.equals(baseMighty))) estimatedTricks += 0.9;
                    if (girudaCards.some(c => c.rank === 'K')) estimatedTricks += 0.7;
                    if (girudaCards.some(c => c.rank === 'Q')) estimatedTricks += 0.4;
                    const lowGirudaCount = girudaCards.filter(c =>
                        !['A', 'K', 'Q'].includes(c.rank) && !c.equals(baseMighty)
                    ).length;
                    if (girudaCards.length >= 5) estimatedTricks += lowGirudaCount * 0.3;
                    else if (girudaCards.length >= 4) estimatedTricks += lowGirudaCount * 0.15;
                }

                for (const suit of Object.values(SUITS)) {
                    if (suit === bestSuit) continue;
                    const suitCards = getCardsOfSuit(hand, suit);
                    if (suitCards.some(c => c.rank === 'A' && !c.equals(baseMighty))) {
                        estimatedTricks += 0.5;
                    }
                }

                // ★★★ 노기루다 평가 (보수적) ★★★
                let noGirudaTricks = 0;
                if (hasMighty) noGirudaTricks += 1.0;
                if (hasJoker) noGirudaTricks += 0.7;

                for (const suit of Object.values(SUITS)) {
                    const suitCards = getCardsOfSuit(hand, suit);
                    const hasAce = suitCards.some(c => c.rank === 'A' && !c.equals(baseMighty));
                    const hasKing = suitCards.some(c => c.rank === 'K');

                    if (hasAce) {
                        if (suitCards.length >= 3) noGirudaTricks += 0.7;
                        else if (suitCards.length >= 2) noGirudaTricks += 0.55;
                        else noGirudaTricks += 0.4;
                    }

                    if (hasKing && !hasAce) {
                        if (suitCards.length >= 3) noGirudaTricks += 0.2;
                        else noGirudaTricks += 0.1;
                    } else if (hasKing && hasAce) {
                        noGirudaTricks += 0.35;
                    }
                }

                const nonZeroCounts = Object.values(suitCounts).filter(c => c > 0);
                const maxSuitCount = Math.max(...Object.values(suitCounts));
                const voidSuitCount = 4 - nonZeroCounts.length;
                if (voidSuitCount >= 1) noGirudaTricks += 0.1;
                if (maxSuitCount >= 5) noGirudaTricks -= 0.3;

                // 기루다 vs 노기루다 비교
                let recommendedGiruda = bestSuit;
                let effectiveTricks = estimatedTricks;

                if (noGirudaTricks > estimatedTricks + 1.0 && noGirudaTricks >= 4.0) {
                    recommendedGiruda = 'none';
                    effectiveTricks = noGirudaTricks;
                }

                // ★★★ 비딩 결정 ★★★
                let shouldPass = true;
                let recommendedBid = GAME_CONFIG.MIN_BID;

                // 친구의 도움을 기대하여 기준 완화 (2.0 트릭부터 비딩 가능)
                if (effectiveTricks >= 2.0) {
                    shouldPass = false;

                    if (effectiveTricks < 2.5) {
                        recommendedBid = 13;
                    } else if (effectiveTricks < 3.0) {
                        recommendedBid = 13;
                    } else if (effectiveTricks < 3.5) {
                        recommendedBid = 13;
                    } else if (effectiveTricks < 4.0) {
                        recommendedBid = 14;
                    } else if (effectiveTricks < 4.5) {
                        recommendedBid = 14;
                    } else if (effectiveTricks < 5.0) {
                        recommendedBid = 15;
                    } else if (effectiveTricks < 5.5) {
                        recommendedBid = 15;
                    } else if (effectiveTricks < 6.0) {
                        recommendedBid = 16;
                    } else if (effectiveTricks < 6.5) {
                        recommendedBid = 16;
                    } else if (effectiveTricks < 7.0) {
                        recommendedBid = 17;
                    } else {
                        recommendedBid = Math.min(18, GAME_CONFIG.MAX_BID);
                    }

                    if (recommendedGiruda === 'none' && recommendedBid > 13) {
                        recommendedBid = Math.max(13, recommendedBid - 2);
                    }
                }


                const totalScore = effectiveTricks * 2;

                return {
                    totalScore,
                    hasMighty,
                    hasJoker,
                    suitCounts,
                    suitStrengths,
                    recommendedGiruda,
                    recommendedBid,
                    shouldPass,
                    noGirudaScore: noGirudaTricks * 2,
                    estimatedTricks: effectiveTricks
                };
            }

            // ★ 노프렌드 평가 함수 (신규)
            evaluateNoFriend(hand, giruda, mighty, bidValue) {
                const hasMighty = hasCard(hand, mighty);
                const hasJoker = hand.some(c => c.isJoker);

                // 마조 동석이 아니면 노프렌드 거의 불가
                if (!hasMighty || !hasJoker) {
                    return { shouldGoAlone: false, reason: null };
                }

                // 기루다 카드 (마이티, 조커 제외한 순수 기루다)
                const girudaCards = giruda
                    ? hand.filter(c => !c.isJoker && c.suit === giruda && !c.equals(mighty))
                    : [];
                const girudaCount = girudaCards.length;
                const girudaHighCards = girudaCards.filter(c => ['A', 'K', 'Q'].includes(c.rank));

                // 비기루다 에이스 (마이티 제외)
                const nonGirudaAces = hand.filter(c =>
                    !c.isJoker && c.rank === 'A' && c.suit !== giruda && !c.equals(mighty)
                );

                // 확실한 트릭 수 추정
                let estimatedTricks = 2; // 마이티 + 조커
                estimatedTricks += girudaHighCards.length * 0.9;
                estimatedTricks += Math.max(0, girudaCount - girudaHighCards.length) * 0.3;
                estimatedTricks += nonGirudaAces.length * 0.7;

                // Case 1: 마조 + 기루다 5장 이상 + 높은 카드 2장 이상
                if (girudaCount >= 5 && girudaHighCards.length >= 2) {
                    return {
                        shouldGoAlone: true,
                        reason: `마조 동석 + 기루다 ${girudaCount}장(높은 카드 ${girudaHighCards.length}장) - 확실한 승리`
                    };
                }

                // Case 2: 마조 + 기루다 4장 + 높은 카드 2장 + 비기루다 A 1장 이상
                if (girudaCount >= 4 && girudaHighCards.length >= 2 && nonGirudaAces.length >= 1) {
                    return {
                        shouldGoAlone: true,
                        reason: `마조 동석 + 기루다 ${girudaCount}장 + 비기루다 A ${nonGirudaAces.length}장 - 강한 패`
                    };
                }

                // Case 3: 마조 + 기루다 4장 + 높은 카드 1장 + 비기루다 A 2장 이상
                if (girudaCount >= 4 && girudaHighCards.length >= 1 && nonGirudaAces.length >= 2) {
                    return {
                        shouldGoAlone: true,
                        reason: `마조 동석 + 기루다 ${girudaCount}장 + 비기루다 A ${nonGirudaAces.length}장`
                    };
                }

                // Case 4: 예상 트릭이 공약 대비 충분하면
                const tricksNeeded = Math.ceil(bidValue / 2.5);
                if (estimatedTricks >= tricksNeeded + 1) {
                    return {
                        shouldGoAlone: true,
                        reason: `마조 동석 + 예상 ${estimatedTricks.toFixed(1)}트릭 ≥ 필요 ${tricksNeeded}+1트릭`
                    };
                }

                // Case 5: 노기루다에서 마조 + A가 3장 이상
                if (!giruda) {
                    const totalAces = hand.filter(c => !c.isJoker && c.rank === 'A').length;
                    const totalKings = hand.filter(c => !c.isJoker && c.rank === 'K').length;
                    if (totalAces >= 3 || (totalAces >= 2 && totalKings >= 2)) {
                        return {
                            shouldGoAlone: true,
                            reason: `마조 동석 + 노기루다 A${totalAces}장 K${totalKings}장 - 강한 패`
                        };
                    }
                }

                return { shouldGoAlone: false, reason: null };
            }

            // ===== 친구 선언 AI =====
            selectFriendCard(playerIndex) {
                const player = this.gameState.players[playerIndex];
                const hand = player.hand;
                const giruda = this.gameState.contract.giruda;
                const mighty = this.gameState.contract.mighty;
                const reasoning = [];

                const hasMighty = hasCard(hand, mighty);
                const hasJoker = hand.some(c => c.isJoker);
                const girudaAce = giruda ? new Card(giruda, 'A') : null;
                const hasGirudaAce = girudaAce && (hasCard(hand, girudaAce) || girudaAce.equals(mighty));
                const girudaCards = giruda ? hand.filter(c => !c.isJoker && c.suit === giruda) : [];
                const girudaCount = girudaCards.length;

                reasoning.push(`마이티 보유: ${hasMighty ? '예' : '아니오'}`);
                reasoning.push(`조커 보유: ${hasJoker ? '예' : '아니오'}`);
                if (giruda) reasoning.push(`기루다 수: ${girudaCount}장`);

                // ★★★ 노프렌드 우선 판단 ★★★
                const noFriendDecision = this.evaluateNoFriend(hand, giruda, mighty, this.gameState.contract.bidValue);
                if (noFriendDecision.shouldGoAlone) {
                    reasoning.push(`노프렌드 선언: ${noFriendDecision.reason}`);
                    return { card: null, isNoFriend: true, reasoning };
                }

                const candidates = [];


                if (!hasMighty) {
                    reasoning.push('마이티 미보유 → 마이티 친구 우선');
                    candidates.push({ card: mighty, priority: 1, reason: '마이티 미보유 - 마이티 친구' });
                }

                if (hasMighty && !hasJoker) {
                    const joker = Card.createJoker();
                    reasoning.push('마이티 보유 + 조커 미보유 → 조커 친구 우선');
                    candidates.push({ card: joker, priority: 1, reason: '마이티 보유, 조커 미보유 - 조커 친구' });
                }

                if (hasMighty && hasJoker) {
                    reasoning.push('마이티 + 조커 보유 → 기루다 A 또는 K 친구');
                    if (girudaAce && !girudaAce.equals(mighty) && !hasCard(hand, girudaAce)) {
                        candidates.push({ card: girudaAce, priority: 1, reason: '마이티+조커 보유 - 기루다 A 친구' });
                    }
                    if (giruda) {
                        const girudaKing = new Card(giruda, 'K');
                        if (!hasCard(hand, girudaKing)) {
                            candidates.push({ card: girudaKing, priority: 2, reason: '마이티+조커 보유 - 기루다 K 친구' });
                        }
                    }
                }

                if (hasMighty && girudaCount <= 2 && giruda) {
                    if (girudaAce && !girudaAce.equals(mighty) && !hasCard(hand, girudaAce)) {
                        candidates.push({ card: girudaAce, priority: 2, reason: '기루다 약함 - 기루다 A 친구' });
                    }
                    const girudaKing = new Card(giruda, 'K');
                    if (!hasCard(hand, girudaKing)) {
                        candidates.push({ card: girudaKing, priority: 3, reason: '기루다 약함 - 기루다 K 친구' });
                    }
                }

                // 백업 후보
                if (girudaAce && !girudaAce.equals(mighty) && !hasCard(hand, girudaAce)) {
                    candidates.push({ card: girudaAce, priority: 10, reason: '백업 - 기루다 A' });
                }
                if (!hasMighty) {
                    candidates.push({ card: mighty, priority: 11, reason: '백업 - 마이티' });
                }
                const joker = Card.createJoker();
                if (!hasJoker) {
                    candidates.push({ card: joker, priority: 12, reason: '백업 - 조커' });
                }
                for (const suit of Object.values(SUITS)) {
                    if (suit === giruda) continue;
                    const ace = new Card(suit, 'A');
                    if (!ace.equals(mighty) && !hasCard(hand, ace)) {
                        candidates.push({ card: ace, priority: 20, reason: `백업 - ${SUIT_NAMES[suit]} A` });
                    }
                }
                if (giruda) {
                    const girudaKing = new Card(giruda, 'K');
                    if (!hasCard(hand, girudaKing)) {
                        candidates.push({ card: girudaKing, priority: 21, reason: '백업 - 기루다 K' });
                    }
                }

                if (candidates.length === 0) {
                    reasoning.push('모든 좋은 카드를 보유 중 - 노프렌드');
                    return { card: null, isNoFriend: true, reasoning };
                }

                const uniqueCandidates = [];
                const seen = new Set();
                for (const c of candidates) {
                    const key = c.card.toString();
                    if (!seen.has(key)) { seen.add(key); uniqueCandidates.push(c); }
                }
                uniqueCandidates.sort((a, b) => a.priority - b.priority);
                const selected = uniqueCandidates[0];
                reasoning.push(`친구 카드 선택: ${selected.card.toString()} (${selected.reason})`);
                return { card: selected.card, isNoFriend: false, reasoning };
            }

            // ===== 카드 교환 AI =====
            selectCardsToDiscard(playerIndex) {
                const player = this.gameState.players[playerIndex];
                const hand = [...player.hand];
                const currentGiruda = this.gameState.contract.giruda;
                const currentBid = this.gameState.contract.bidValue;
                const reasoning = [];

                const girudaChangeDecision = this.shouldChangeGiruda(hand, currentGiruda, currentBid);
                const giruda = girudaChangeDecision.newGiruda || currentGiruda;
                const mighty = giruda === SUITS.SPADE
                    ? new Card(SUITS.DIAMOND, 'A')
                    : new Card(SUITS.SPADE, 'A');

                const mustKeep = new Set();
                mustKeep.add(mighty.toString());
                if (hand.some(c => c.isJoker)) mustKeep.add('JOKER');

                const suitCounts = {};
                for (const suit of Object.values(SUITS)) {
                    suitCounts[suit] = getCardsOfSuit(hand, suit).length;
                }

                const getDiscardPriority = (card) => {
                    if (mustKeep.has(card.toString())) return 1000;
                    let priority = 0;
                    if (card.isPointCard()) priority += 100;
                    if (!card.isJoker && giruda && card.suit === giruda) priority += 50;
                    if (!card.isJoker) priority += RANK_VALUES[card.rank];
                    if (!card.isJoker) priority -= suitCounts[card.suit] * 10;
                    return priority;
                };

                const sorted = [...hand].sort((a, b) => getDiscardPriority(a) - getDiscardPriority(b));
                const toDiscard = sorted.slice(0, 3).filter(c => !mustKeep.has(c.toString()));

                while (toDiscard.length < 3) {
                    for (const card of sorted) {
                        if (!toDiscard.some(c => c.equals(card)) && !mustKeep.has(card.toString())) {
                            toDiscard.push(card); break;
                        }
                    }
                    if (toDiscard.length < 3) {
                        for (const card of sorted) {
                            if (!toDiscard.some(c => c.equals(card))) { toDiscard.push(card); break; }
                        }
                    }
                }

                reasoning.push(`버릴 카드: ${toDiscard.map(c => c.toString()).join(', ')}`);
                if (girudaChangeDecision.shouldChange) reasoning.unshift(girudaChangeDecision.reason);

                return {
                    cards: toDiscard.slice(0, 3),
                    reasoning,
                    newGiruda: girudaChangeDecision.shouldChange ? girudaChangeDecision.newGiruda : null,
                    isNoGiruda: girudaChangeDecision.isNoGiruda || false,
                    isSolino: girudaChangeDecision.isSolino || false
                };
            }

            shouldChangeGiruda(hand, currentGiruda, currentBid) {
                const isMaxBid = currentBid >= GAME_CONFIG.MAX_BID;
                const isCurrentNoGiruda = this.gameState.contract.isNoGiruda;
                const suitAnalysis = {};
                for (const suit of Object.values(SUITS)) {
                    const suitCards = getCardsOfSuit(hand, suit);
                    const count = suitCards.length;
                    const highCards = suitCards.filter(c => ['A', 'K', 'Q', 'J'].includes(c.rank));
                    const strength = count * 2 + highCards.length * 1.5;
                    suitAnalysis[suit] = { count, highCards: highCards.length, strength };
                }

                const baseMighty = new Card(SUITS.SPADE, 'A');
                const hasMighty = hasCard(hand, baseMighty);
                const hasJoker = hand.some(c => c.isJoker);

                // ★★★ 노기루다로 비딩한 경우: 기루다 변경하지 않음 ★★★
                if (isCurrentNoGiruda) {
                    // 20 비딩이면 솔리노만 판단
                    if (isMaxBid && hasMighty && hasJoker) {
                        const aceCount = hand.filter(c => !c.isJoker && c.rank === 'A').length;
                        const kingCount = hand.filter(c => !c.isJoker && c.rank === 'K').length;
                        if (aceCount >= 3 || (aceCount >= 2 && kingCount >= 2)) {
                            return { shouldChange: true, newGiruda: null, isNoGiruda: true, isSolino: true, reason: '노기루다 솔리노 선언' };
                        }
                    }
                    return { shouldChange: false, newGiruda: null, isNoGiruda: false, isSolino: false, reason: null };
                }

                if (isMaxBid) {
                    const currentAnalysis = currentGiruda ? suitAnalysis[currentGiruda] : { count: 0, strength: 0 };
                    // 솔리노 판단
                    if (hasMighty && hasJoker) {
                        const girudaCards = currentGiruda
                            ? hand.filter(c => !c.isJoker && c.suit === currentGiruda && !c.equals(getMighty(currentGiruda)))
                            : [];
                        const girudaHighCards = girudaCards.filter(c => ['A', 'K', 'Q'].includes(c.rank));
                        const nonGirudaAces = hand.filter(c =>
                            !c.isJoker && c.rank === 'A' && c.suit !== currentGiruda && !c.equals(getMighty(currentGiruda))
                        );
                        if (
                            (girudaCards.length >= 5 && girudaHighCards.length >= 2) ||
                            (girudaCards.length >= 4 && girudaHighCards.length >= 2 && nonGirudaAces.length >= 1) ||
                            (girudaCards.length >= 4 && girudaHighCards.length >= 1 && nonGirudaAces.length >= 2)
                        ) {
                            return { shouldChange: true, newGiruda: null, isNoGiruda: false, isSolino: true, reason: '솔리노 선언 (마조 동석 + 강한 패)' };
                        }
                    }

                    let bestSuit = currentGiruda;
                    let bestStrength = currentGiruda ? suitAnalysis[currentGiruda].strength : 0;
                    for (const [suit, analysis] of Object.entries(suitAnalysis)) {
                        if (analysis.strength > bestStrength) { bestSuit = suit; bestStrength = analysis.strength; }
                    }
                    if (bestSuit && bestSuit !== currentGiruda) {
                        const oldName = currentGiruda ? SUIT_NAMES[currentGiruda] : '노기루다';
                        return { shouldChange: true, newGiruda: bestSuit, isNoGiruda: false, isSolino: false, reason: `기루다 무료 변경: ${oldName} → ${SUIT_NAMES[bestSuit]}` };
                    }
                    return { shouldChange: false, newGiruda: null, isNoGiruda: false, isSolino: false, reason: null };
                }

                const currentAnalysis = currentGiruda ? suitAnalysis[currentGiruda] : { count: 0, strength: 0 };
                let bestSuit = currentGiruda;
                let bestStrength = currentAnalysis.strength;
                for (const [suit, analysis] of Object.entries(suitAnalysis)) {
                    if (suit !== currentGiruda) {
                        const countDiff = analysis.count - currentAnalysis.count;
                        const strengthDiff = analysis.strength - currentAnalysis.strength;
                        if ((countDiff >= 2 || strengthDiff >= 5) && analysis.strength > bestStrength) {
                            bestSuit = suit; bestStrength = analysis.strength;
                        }
                    }
                }
                if (bestSuit && bestSuit !== currentGiruda) {
                    const newBid = Math.min(currentBid + 2, GAME_CONFIG.MAX_BID);
                    const oldName = currentGiruda ? SUIT_NAMES[currentGiruda] : '노기루다';
                    return { shouldChange: true, newGiruda: bestSuit, isNoGiruda: false, isSolino: false, reason: `기루다 변경: ${oldName} → ${SUIT_NAMES[bestSuit]} (공약 ${currentBid} → ${newBid})` };
                }
                return { shouldChange: false, newGiruda: null, isNoGiruda: false, isSolino: false, reason: null };
            }


            // ===== 카드 플레이 AI =====
            selectCardToPlay(playerIndex) {
                const player = this.gameState.players[playerIndex];
                const hand = player.hand;
                const teamContext = this.gameState.getTeamContext(playerIndex);
                const trickAnalysis = this.gameState.analyzeTrick(playerIndex);
                const round = this.gameState.round;
                const reasoning = [];
                const trackingSummary = this.gameState.getCardTrackingSummary(playerIndex, hand);

                const isLead = this.gameState.trick.cards.length === 0;
                const isGovernment = teamContext.myRole === ROLES.MASTER || teamContext.myRole === ROLES.FRIEND;

                reasoning.push(`역할: ${player.getRoleText() || '야당'}`);
                reasoning.push(`남은 점수: ${trackingSummary.pointsRemaining}점`);

                // 조커콜 당한 경우
                if (this.gameState.trick.jokerCalled) {
                    const joker = hand.find(c => c.isJoker);
                    if (joker) {
                        const mighty = this.gameState.contract.mighty;
                        if (hasCard(hand, mighty)) {
                            const shouldDefend = this.shouldDefendJokerCallWithMighty(hand, isGovernment, round);
                            if (shouldDefend) {
                                reasoning.push('조커콜 - 마이티로 방어 (조커 보존)');
                                return { card: mighty, reasoning };
                            }
                        }
                        reasoning.push('조커콜 - 조커 강제 출전');
                        return { card: joker, reasoning };
                    }
                }

                let selectedCard;
                if (isLead) {
                    reasoning.push('선(리드) 차례');
                    selectedCard = isGovernment
                        ? this.governmentLeadStrategy(hand, trickAnalysis, teamContext, reasoning, trackingSummary)
                        : this.oppositionLeadStrategy(hand, trickAnalysis, teamContext, reasoning, trackingSummary);
                } else {
                    reasoning.push(`리드 수트: ${SUIT_NAMES[trickAnalysis.leadSuit] || '없음'}`);
                    if (trickAnalysis.isGovernmentWinning) reasoning.push('현재 여당이 이기는 중');
                    else if (trickAnalysis.isOppositionWinning) reasoning.push('현재 야당이 이기는 중');
                    reasoning.push(`트릭 내 점수: ${trickAnalysis.pointsInTrick}점`);

                    selectedCard = isGovernment
                        ? this.governmentFollowStrategy(hand, trickAnalysis, teamContext, reasoning, trackingSummary)
                        : this.oppositionFollowStrategy(hand, trickAnalysis, teamContext, reasoning, trackingSummary);
                }

                reasoning.push(`선택: ${selectedCard.toString()}`);

                let jokerCallSuit = null;
                if (isLead && selectedCard.isJoker && round >= 2 && round <= 9) {
                    jokerCallSuit = this.selectJokerCallSuit(hand, teamContext);
                    reasoning.push(`조커 수트 선언: ${SUIT_NAMES[jokerCallSuit]}`);
                }

                return { card: selectedCard, jokerCallSuit, reasoning };
            }

            shouldDefendJokerCallWithMighty(hand, isGovernment, round) {
                const remainingRounds = 10 - round;
                if (remainingRounds <= 3) return true;
                if (isGovernment && round <= 5) return false;
                return true;
            }

            shouldPlayJoker(hand, trickAnalysis, teamContext, isLead, round, trackingSummary = null) {
                if (round === 1 || round === 10) return { shouldPlay: false };
                const isGovernment = teamContext.myRole === ROLES.MASTER || teamContext.myRole === ROLES.FRIEND;
                const { isGovernmentWinning, isOppositionWinning, pointsInTrick, hasGovernmentRemaining } = trickAnalysis;
                const mightyPlayed = trackingSummary ? trackingSummary.mightyPlayed : this.gameState.mightyUsed;
                const remainingPoints = trackingSummary ? trackingSummary.pointsRemaining : 20 - round * 2;

                if (isLead) {
                    if (!isGovernment && !mightyPlayed) {
                        if (round >= 8 || remainingPoints <= 4) return { shouldPlay: true, callSuit: this.selectJokerCallSuit(hand, teamContext) };
                        return { shouldPlay: false };
                    }
                    if (round >= 6 || remainingPoints >= 8) return { shouldPlay: true, callSuit: this.selectJokerCallSuit(hand, teamContext) };
                    return { shouldPlay: false };
                }

                const mightyPlayedInTrick = this.gameState.trick.cards.some(p => p.card.equals(this.gameState.contract.mighty));
                if (mightyPlayedInTrick) return { shouldPlay: false };

                if (!isGovernment) {
                    if (!mightyPlayed) {
                        if (isGovernmentWinning && pointsInTrick >= 2) return { shouldPlay: true };
                        if (isGovernmentWinning && round >= 7) return { shouldPlay: true };
                        if (pointsInTrick >= 3) return { shouldPlay: true };
                        return { shouldPlay: false };
                    }

                    if (isGovernmentWinning && pointsInTrick >= 1) return { shouldPlay: true };
                    if (isGovernmentWinning && round >= 6) return { shouldPlay: true };
                    if (pointsInTrick >= 2) return { shouldPlay: true };
                    if (round >= 8) return { shouldPlay: true };
                    return { shouldPlay: false };
                }

                if (isGovernment && isOppositionWinning && pointsInTrick >= 1) return { shouldPlay: true };
                return { shouldPlay: false };
            }

            shouldPlayMighty(hand, trickAnalysis, teamContext, isLead, round, trackingSummary = null) {
                const mighty = this.gameState.contract.mighty;
                if (!hasCard(hand, mighty)) return false;
                const isGovernment = teamContext.myRole === ROLES.MASTER || teamContext.myRole === ROLES.FRIEND;
                const isFriend = teamContext.myRole === ROLES.FRIEND;
                const { isGovernmentWinning, isOppositionWinning, pointsInTrick, playableCards } = trickAnalysis;

                if (playableCards.length === 1 && playableCards[0].equals(mighty)) return true;

                const remainingPoints = trackingSummary ? trackingSummary.pointsRemaining : 20 - round * 2;
                const jokerStillInPlay = trackingSummary ? !trackingSummary.jokerPlayed : true;

                if (isLead) {
                    if (round >= 7) return true;
                    if (remainingPoints >= 10 && !jokerStillInPlay) return true;
                    return false;
                }

                const leadPlayer = this.gameState.trick.leadPlayer;
                const masterIndex = this.gameState.contract.master;
                const isMasterLead = (leadPlayer === masterIndex);

                if (isGovernment) {
                    if (isFriend && isMasterLead && isOppositionWinning) {
                        if (pointsInTrick >= 3) return true;
                        if (pointsInTrick >= 2 && round >= 6) return true;
                        if (pointsInTrick >= 2 && !trickAnalysis.hasOppositionRemaining) return true;
                        if (pointsInTrick >= 1 && round >= 8) return true;
                        if (round >= 9) return true;
                        return false;
                    }


                    if (isOppositionWinning && pointsInTrick >= 1) return true;
                    const pointsNeeded = this.gameState.contract.bidValue - this.gameState.governmentScore;
                    if (round >= 6 && pointsNeeded > 0 && pointsInTrick >= 1) return true;
                    if (remainingPoints <= 6 && pointsInTrick >= 1 && isOppositionWinning) return true;

                    // ★ 주공 본인이 마이티를 쓰는 조건도 완화
                    if (isOppositionWinning && pointsInTrick >= 3) return true;

                    if (round >= 8 && pointsNeeded > 0 && pointsInTrick >= 2) return true;
                    if (remainingPoints <= 6 && pointsInTrick >= 2 && isOppositionWinning) return true;
                } else {
                    // 야당이 마이티 보유
                    if (isGovernmentWinning && pointsInTrick >= 2) return true;  // 2점 이상이면 탈환
                    if (isGovernmentWinning && round >= 7) return true;  // 후반부면 점수 무관 탈환
                    if (pointsInTrick >= 3) return true;  // 고점수 트릭은 누가 이기든 확보
                    if (remainingPoints <= 6 && isGovernmentWinning) return true;  // 막판 추격
                    if (round >= 9) return true;  // 9~10라운드는 무조건 사용 (안 쓰면 낭비)
                }
                return false;
            }

            // ===== 여당 리드 전략 =====
                        // ===== 여당 리드 전략 (분기점) =====
            governmentLeadStrategy(hand, trickAnalysis, teamContext, reasoning, trackingSummary = null) {
                const isFriend = teamContext.myRole === ROLES.FRIEND;
                if (isFriend) {
                    return this.friendLeadStrategy(hand, trickAnalysis, teamContext, reasoning, trackingSummary);
                } else {
                    return this.masterLeadStrategy(hand, trickAnalysis, teamContext, reasoning, trackingSummary);
                }
            }

            // ===== 주공 리드 전략 =====
            masterLeadStrategy(hand, trickAnalysis, teamContext, reasoning, trackingSummary = null) {
                const { playableCards } = trickAnalysis;
                const giruda = this.gameState.contract.giruda;
                const mighty = this.gameState.contract.mighty;
                const round = this.gameState.round;
                const friendCard = this.gameState.contract.friendCard;
                const jokerCall = this.gameState.contract.jokerCall;

                const govScore = this.gameState.governmentScore;
                const bidValue = this.gameState.contract.bidValue;
                const pointsNeeded = bidValue - govScore;

                const hasMighty = hasCard(hand, mighty);
                const hasJoker = hand.some(c => c.isJoker);
                const joker = hand.find(c => c.isJoker);

                // ── 공약 달성 완료 → 방어적 플레이 ──
                if (pointsNeeded <= 0) {
                    reasoning.push('공약 달성 완료 - 방어적 플레이');
                    return this.selectLowestNonPointCard(playableCards) || this.selectLowestCard(playableCards);
                }

                // ── 9라운드 조커 강제 리드 (10라운드에서는 조커 무효) ──
                if (round === 9 && hasJoker) {
                    reasoning.push('9라운드 - 조커 강제 리드 (10라운드 무효화 방지)');
                    return joker;
                }

                

                // ── 초구 전략 (주공 전용) ──
                if (round === 1) {
                    reasoning.push('초구 전략 (주공)');
                    const isFriendMighty = friendCard && friendCard.equals(mighty);
                    const isFriendJoker = friendCard && friendCard.isJoker;

                    if (hasMighty) {
                        reasoning.push('초구 - 마이티 리드');
                        return mighty;
                    }
                    if (isFriendMighty) {
                        reasoning.push('초구 - 친구가 마이티 (낮은 카드로 유도)');
                        const nonGirudaCards = playableCards.filter(c => !c.isJoker && c.suit !== giruda && !c.isPointCard());
                        if (nonGirudaCards.length > 0) return this.selectLowestCard(nonGirudaCards);
                        const nonPointCards = playableCards.filter(c => !c.isJoker && !c.isPointCard());
                        if (nonPointCards.length > 0) return this.selectLowestCard(nonPointCards);
                        return this.selectLowestCard(playableCards);
                    }
                    if (isFriendJoker) {
                        reasoning.push('초구 - 친구가 조커 (1라운드 조커 무효)');
                        if (giruda) {
                            const girudaCards = getCardsOfSuit(hand, giruda);
                            for (const card of girudaCards) {
                                if (this.gameState.getCardAnalysis(card).isBoss) {
                                    reasoning.push('초구 - 기루다 보스카드 리드');
                                    return card;
                                }
                            }
                        }
                    }

                    const girudaAce = giruda ? new Card(giruda, 'A') : null;
                    if (friendCard && girudaAce && friendCard.equals(girudaAce) && giruda) {
                        reasoning.push('초구 - 친구가 기루다 A (기루다 리드)');
                        const girudaCards = getCardsOfSuit(hand, giruda);
                        if (girudaCards.length > 0) return this.selectLowestCard(girudaCards);
                    }

                    // 초구에서 조커콜 카드 리드 방지
                    const bossCards = playableCards.filter(c => {
                        if (c.isJoker || c.equals(mighty)) return false;
                        if (round === 1 && jokerCall && c.equals(jokerCall)) return false;
                        return this.gameState.getCardAnalysis(c).isBoss;
                    });
                    if (bossCards.length > 0) {
                        const girudaBoss = bossCards.find(c => c.suit === giruda);
                        if (girudaBoss) { reasoning.push('초구 - 기루다 보스카드 리드'); return girudaBoss; }
                        const pointBoss = bossCards.filter(c => c.isPointCard());
                        if (pointBoss.length > 0) { reasoning.push('초구 - 점수 보스카드 리드'); return this.selectHighestCard(pointBoss); }
                    }

                    reasoning.push('초구 - 낮은 카드로 친구 유도');
                    const nonPointCards = playableCards.filter(c => !c.isJoker && !c.isPointCard());
                    if (nonPointCards.length > 0) return this.selectLowestCard(nonPointCards);
                    return this.selectLowestCard(playableCards);
                }

                // ── 마이티 사용 결정 ──
                if (this.shouldPlayMighty(hand, trickAnalysis, teamContext, true, round, trackingSummary)) {
                    reasoning.push('주공 마이티 리드');
                    return mighty;
                }

                // ── 기루다 보스카드 리드 (조커보다 우선) ──
                if (giruda) {
                    const girudaCards = getCardsOfSuit(hand, giruda);
                    const girudaBossCandidates = girudaCards
                        .filter(c => !c.equals(mighty))
                        .filter(c => this.gameState.getCardAnalysis(c).isBoss);
                    if (girudaBossCandidates.length > 0) {
                        const bestBoss = this.selectHighestCard(girudaBossCandidates);
                        reasoning.push(`기루다 보스카드 ${bestBoss.toString()} 리드 (확정 승리)`);
                        return bestBoss;
                    }
                }

                // ── 비기루다 보스 A 리드 (조커보다 우선) ──
                for (const suit of Object.values(SUITS)) {
                    if (suit === giruda) continue;
                    const suitCards = getCardsOfSuit(hand, suit);
                    const ace = suitCards.find(c => c.rank === 'A' && !c.equals(mighty));
                    if (ace && this.gameState.getCardAnalysis(ace).isBoss) {
                        reasoning.push(`${SUIT_NAMES[suit]} A 리드 (보스카드)`);
                        return ace;
                    }
                }

                // ── 보스카드가 없을 때 조커 사용 ──
                const jokerDecision = this.shouldPlayJoker(hand, trickAnalysis, teamContext, true, round, trackingSummary);
                if (jokerDecision.shouldPlay && hasJoker) {
                    reasoning.push('조커 리드 (보스카드 없음)');
                    return joker;
                }

                // ── 조커콜 전략 ──
                const hasJokerCallCard = jokerCall && hand.some(c => c.equals(jokerCall));
                const isJokerStillOut = !this.gameState.jokerUsed;
                if (round >= 2 && round <= 9 && hasJokerCallCard && isJokerStillOut) {
                    const iHaveJoker = hand.some(c => c.isJoker);
                    // 사연 응답으로 친구가 조커를 가지고 있다고 알려진 경우 조커콜 금지
                    const friendHasJoker = this.gameState.sayeonResponse === '넌사';
                    if (!iHaveJoker && !friendHasJoker && round >= 5) {
                        reasoning.push('조커콜 - 야당 조커 견제');
                        return jokerCall;
                    }
                }
                // ── 수트 절제(Void) 전략 ──
                if (giruda) {
                    const girudaCardsInHand = getCardsOfSuit(hand, giruda);
                    if (girudaCardsInHand.length > 0) {
                        const shortSuits = [];
                        for (const suit of Object.values(SUITS)) {
                            if (suit === giruda) continue;
                            const suitCards = getCardsOfSuit(hand, suit);
                            if (suitCards.length === 1 || suitCards.length === 2) {
                                shortSuits.push({ suit, cards: suitCards, count: suitCards.length });
                            }
                        }
                        for (const ss of shortSuits.sort((a, b) => a.count - b.count)) {
                            const bosses = ss.cards.filter(c => this.gameState.getCardAnalysis(c).isBoss);
                            if (bosses.length > 0) {
                                reasoning.push(`수트 절제 - ${SUIT_NAMES[ss.suit]} 보스카드 리드 (${ss.count}장)`);
                                return this.selectHighestCard(bosses);
                            }
                        }
                    }
                }

                // ── 친구에게 트릭 넘기기 ──
                let friendCardSuit = null;
                let friendCardRank = null;
                if (friendCard && !friendCard.isJoker) { friendCardSuit = friendCard.suit; friendCardRank = friendCard.rank; }

                const hasBossCard = playableCards.some(c => {
                    if (c.isJoker || c.equals(mighty)) return false;
                    return this.gameState.getCardAnalysis(c).isBoss;
                });

                if (!hasBossCard && friendCard && !friendCard.isJoker && friendCardSuit) {
                    const sameSuitCards = getCardsOfSuit(hand, friendCardSuit);
                    if (sameSuitCards.length > 0) {
                        const lowerCards = sameSuitCards.filter(c => RANK_VALUES[c.rank] < RANK_VALUES[friendCardRank]);
                        if (lowerCards.length > 0 && this.gameState.isCardStillInPlay(friendCard)) {
                            reasoning.push(`친구 카드(${friendCard.toString()}) 활용`);
                            return this.selectLowestCard(lowerCards);
                        }
                    }
                }

                // ── 가장 긴 수트 리드 ──
                const longestSuit = this.findLongestSuit(hand, giruda);
                if (longestSuit) {
                    const suitCards = getCardsOfSuit(hand, longestSuit);
                    if (suitCards.length > 0) {
                        const bossInSuit = suitCards.find(c => this.gameState.getCardAnalysis(c).isBoss);
                        if (bossInSuit) { reasoning.push(`${SUIT_NAMES[longestSuit]} 보스카드 리드`); return bossInSuit; }
                        reasoning.push(`${SUIT_NAMES[longestSuit]} 리드 (낮은 카드)`);
                        return this.selectLowestCard(suitCards);
                    }
                }

                // ── 폴백 ──
                if (hasBossCard) return this.selectHighestCard(playableCards);
                return this.selectLowestCard(playableCards);
            }

            // ===== 친구 리드 전략 =====
            friendLeadStrategy(hand, trickAnalysis, teamContext, reasoning, trackingSummary = null) {
                const { playableCards } = trickAnalysis;
                const giruda = this.gameState.contract.giruda;
                const mighty = this.gameState.contract.mighty;
                const round = this.gameState.round;
                const masterIndex = this.gameState.contract.master;
                const jokerCall = this.gameState.contract.jokerCall;

                const govScore = this.gameState.governmentScore;
                const bidValue = this.gameState.contract.bidValue;
                const pointsNeeded = bidValue - govScore;

                const hasMighty = hasCard(hand, mighty);
                const hasJoker = hand.some(c => c.isJoker);
                const joker = hand.find(c => c.isJoker);

                // 마이티/조커 제외한 일반 카드
                const normalCards = playableCards.filter(c => !c.isJoker && !c.equals(mighty));
                // 보스카드 목록
                const bossCards = normalCards.filter(c => this.gameState.getCardAnalysis(c).isBoss);

                // 주공의 void 수트 정보
                const masterVoidSuits = trackingSummary?.playerVoidSuits?.[masterIndex]
                    ? new Set(trackingSummary.playerVoidSuits[masterIndex])
                    : (this.gameState.playerVoidSuits.get(masterIndex) || new Set());

                reasoning.push('친구 리드 전략');

                // ── 공약 달성 완료 → 방어적 플레이 ──
                if (pointsNeeded <= 0) {
                    reasoning.push('공약 달성 완료 - 방어적 플레이');
                    return this.selectLowestNonPointCard(playableCards) || this.selectLowestCard(playableCards);
                }

                // ── 9라운드 조커 강제 리드 (10라운드에서는 조커 무효) ──
                if (round === 9 && hasJoker) {
                    reasoning.push('9라운드 - 조커 강제 리드 (10라운드 무효화 방지)');
                    return joker;
                }

                
                // ──────────────────────────────────────
                // ★★★ 정상 플레이: 친구의 핵심 전략 ★★★
                // 원칙: 보스카드 > 기루다 소진 > 주공 void 활용 > 주공 강세 수트
                //       마이티/조커는 최후의 수단
                // ──────────────────────────────────────

                // ── 1. 기루다 보스카드 리드 (최우선) ──
                if (giruda) {
                    const girudaBoss = bossCards.find(c => c.suit === giruda);
                    if (girudaBoss) {
                        reasoning.push(`기루다 보스카드 리드: ${girudaBoss.toString()} (확정 승리)`);
                        return girudaBoss;
                    }
                }

                // ── 2. 비기루다 보스카드 리드 ──
                if (bossCards.length > 0) {
                    // 점수 보스카드 우선
                    const pointBoss = bossCards.filter(c => c.isPointCard());
                    if (pointBoss.length > 0) {
                        reasoning.push('비기루다 보스카드 리드 (점수 확보)');
                        return this.selectHighestCard(pointBoss);
                    }
                    // 후반부에는 비점수 보스카드도 리드 (리드권 유지)
                    if (round >= 5) {
                        reasoning.push('보스카드 리드 (리드권 유지)');
                        return this.selectHighestCard(bossCards);
                    }
                }

                // ── 3. 기루다 소진 전략 (초~중반) ──
                // 야당의 기루다를 소진시켜 주공의 기루다 우위 확보
                if (giruda && round >= 2 && round <= 7) {
                    const myGirudaCards = getCardsOfSuit(hand, giruda).filter(c => !c.equals(mighty));
                    const remainingGiruda = this.gameState.getRemainingCardsOfSuit(giruda);
                    const otherGirudaCount = remainingGiruda.filter(c =>
                        !myGirudaCards.some(mc => mc.equals(c)) && !c.equals(mighty)
                    ).length;

                    if (myGirudaCards.length > 0 && otherGirudaCount > 0) {
                        // 높은 기루다부터 리드
                        const highGiruda = myGirudaCards.filter(c => RANK_VALUES[c.rank] >= 10);
                        if (highGiruda.length > 0) {
                            reasoning.push(`기루다 소진 - 높은 기루다 리드 (야당 기루다 ${otherGirudaCount}장 남음)`);
                            return this.selectHighestCard(highGiruda);
                        }
                        // 높은 카드 없으면 낮은 기루다 (주공이 보스카드 가지고 있을 수 있음)
                        if (myGirudaCards.length >= 2) {
                            reasoning.push(`기루다 소진 - 낮은 기루다 리드 (기루다 ${myGirudaCards.length}장 보유)`);
                            return this.selectLowestCard(myGirudaCards);
                        }
                    }
                }

                // ── 4. 주공 void 수트 리드 (기루다 컷 유도) ──
                if (masterVoidSuits.size > 0 && giruda) {
                    const masterVoidGiruda = masterVoidSuits.has(giruda);

                    if (!masterVoidGiruda) {
                        for (const voidSuit of masterVoidSuits) {
                            if (voidSuit === giruda) continue;
                            const mySuitCards = getCardsOfSuit(hand, voidSuit);
                            if (mySuitCards.length > 0) {
                                // 점수 카드가 있으면 점수 카드 리드 (주공이 기루다 컷으로 가져감)
                                const pointCardsInSuit = mySuitCards.filter(c => c.isPointCard());
                                if (pointCardsInSuit.length > 0) {
                                    const nonBossPoint = pointCardsInSuit.filter(c => !this.gameState.getCardAnalysis(c).isBoss);
                                    if (nonBossPoint.length > 0) {
                                        reasoning.push(`주공 ${SUIT_NAMES[voidSuit]} void → 점수 카드 리드 (기루다 컷 유도)`);
                                        return this.selectHighestCard(nonBossPoint);
                                    }
                                }
                                // 비점수 카드 리드
                                const nonPointCards = mySuitCards.filter(c => !c.isPointCard());
                                if (nonPointCards.length > 0) {
                                    reasoning.push(`주공 ${SUIT_NAMES[voidSuit]} void → 물카 리드 (기루다 컷 유도)`);
                                    return this.selectLowestCard(nonPointCards);
                                }
                                reasoning.push(`주공 ${SUIT_NAMES[voidSuit]} void → 리드`);
                                return this.selectHighestCard(mySuitCards);
                            }
                        }
                    }
                }

                // ── 5. 주공 강세 수트 리드 ──
                const masterPlayedSuits = new Map();
                for (const played of this.gameState.cardTracker.playedCards) {
                    if (played.player === masterIndex && !played.card.isJoker) {
                        const s = played.card.suit;
                        masterPlayedSuits.set(s, (masterPlayedSuits.get(s) || 0) + 1);
                    }
                }

                const masterStrongSuits = [];
                for (const [suit, count] of masterPlayedSuits) {
                    if (suit === giruda) continue;
                    if (masterVoidSuits.has(suit)) continue;
                    const myCards = getCardsOfSuit(hand, suit);
                    if (myCards.length > 0) {
                        masterStrongSuits.push({ suit, masterCount: count, myCards });
                    }
                }

                if (masterStrongSuits.length > 0) {
                    masterStrongSuits.sort((a, b) => b.masterCount - a.masterCount);
                    for (const { suit, myCards } of masterStrongSuits) {
                        const nonBossLow = myCards.filter(c =>
                            !this.gameState.getCardAnalysis(c).isBoss && !c.isPointCard()
                        );
                        if (nonBossLow.length > 0) {
                            reasoning.push(`주공 ${SUIT_NAMES[suit]} 강세 추정 → 낮은 카드 리드 (주공 승리 유도)`);
                            return this.selectLowestCard(nonBossLow);
                        }
                    }
                }

                // ── 6. 조커콜 전략 ──
                const hasJokerCallCard = jokerCall && hand.some(c => c.equals(jokerCall));
const isJokerStillOut = !this.gameState.jokerUsed;
if (round >= 2 && round <= 9 && hasJokerCallCard && isJokerStillOut) {
    const iHaveJoker = hand.some(c => c.isJoker);
    // 사연을 안 물었으면 주공이 조커 보유 → 여당 조커이므로 조커콜 금지
    const sayeon = this.gameState.sayeonResponse;
    const masterHasJoker = (sayeon === null && this.gameState.settings?.useSayeon !== false);
    // 사연 응답이 '넌사'면 친구(나)가 조커 보유 → 조커콜 금지
    const friendHasJoker = (sayeon === '넌사');
    if (!iHaveJoker && !masterHasJoker && !friendHasJoker && round >= 5) {
        reasoning.push('조커콜 - 야당 조커 견제');
        return jokerCall;
    }
    if (masterHasJoker) {
        reasoning.push('조커콜 금지 - 사연 미실시, 주공이 조커 보유 추정');
    }
    if (friendHasJoker) {
        reasoning.push('조커콜 금지 - 사연 응답으로 친구 조커 보유 확인');
    }
}

                // ── 7. 조커 리드 (보스카드/기루다/void 전략이 모두 없을 때) ──
                if (hasJoker && round >= 2 && round <= 8) {
                    // 마이티가 아직 살아있고 내가 안 가지고 있으면 조심
                    const mightyStillInPlay = this.gameState.isMightyStillInPlay();
                    const canSafeJoker = !mightyStillInPlay || hasMighty;
                    if (canSafeJoker) {
                        reasoning.push('조커 리드 (보스카드/기루다 전략 없음, 마이티 안전)');
                        return joker;
                    }
                    // 후반부에는 위험 감수
                    if (round >= 6) {
                        reasoning.push('조커 리드 (후반부 - 마이티 위험 감수)');
                        return joker;
                    }
                }

                // ── 8. 마이티 리드 (친구는 최후의 수단으로만) ──
                // 마지막 2라운드이거나, 다른 카드가 모두 비점수 낮은 카드뿐일 때만
                if (hasMighty) {
                    if (playableCards.length === 1 && playableCards[0].equals(mighty)) {
                        reasoning.push('친구 마이티 리드 (유일한 카드)');
                        return mighty;
                    }
                    // 마이티 외에 낼 카드가 있으면 마이티는 리드하지 않음
                    const nonMightyPlayable = playableCards.filter(c => !c.equals(mighty));
                    if (nonMightyPlayable.length > 0) {
                        reasoning.push('마이티 보존 - 다른 카드로 리드');
                        // 마이티를 리드하지 않고 아래 9번으로 넘김
                    } else if (round >= 9) {
                        reasoning.push('친구 마이티 리드 (최후 라운드 + 다른 카드 없음)');
                        return mighty;
                    }
                }


                // ── 9. 비기루다 일반 카드 리드 ──
                // 가능하면 비점수 + 비보스 + 비기루다
                const nonGirudaNonBossNonPoint = normalCards.filter(c =>
                    c.suit !== giruda &&
                    !this.gameState.getCardAnalysis(c).isBoss &&
                    !c.isPointCard()
                );
                if (nonGirudaNonBossNonPoint.length > 0) {
                    // 짧은 수트 우선 (void 만들기)
                    const suitGroups = new Map();
                    for (const c of nonGirudaNonBossNonPoint) {
                        if (!suitGroups.has(c.suit)) suitGroups.set(c.suit, []);
                        suitGroups.get(c.suit).push(c);
                    }
                    let shortestSuit = null;
                    let shortestCount = Infinity;
                    for (const [suit, cards] of suitGroups) {
                        const totalInSuit = getCardsOfSuit(hand, suit).length;
                        if (totalInSuit < shortestCount) {
                            shortestCount = totalInSuit;
                            shortestSuit = suit;
                        }
                    }
                    if (shortestSuit) {
                        reasoning.push(`${SUIT_NAMES[shortestSuit]} 리드 (짧은 수트 정리)`);
                        return this.selectLowestCard(suitGroups.get(shortestSuit));
                    }
                    reasoning.push('비기루다 낮은 카드 리드');
                    return this.selectLowestCard(nonGirudaNonBossNonPoint);
                }

                // ── 10. 기루다 낮은 카드 리드 ──
                if (giruda) {
                    const girudaNonBoss = getCardsOfSuit(hand, giruda).filter(c =>
                        !c.equals(mighty) && !this.gameState.getCardAnalysis(c).isBoss
                    );
                    if (girudaNonBoss.length > 0) {
                        reasoning.push('기루다 낮은 카드 리드');
                        return this.selectLowestCard(girudaNonBoss);
                    }
                }

                // ── 11. 폴백 ──
                reasoning.push('폴백 - 가장 낮은 카드');
                return this.selectLowestNonPointCard(playableCards) || this.selectLowestCard(playableCards);
            }


            // ===== 야당 리드 전략 =====
            oppositionLeadStrategy(hand, trickAnalysis, teamContext, reasoning, trackingSummary = null) {
                const { playableCards } = trickAnalysis;
                const giruda = this.gameState.contract.giruda;
                const mighty = this.gameState.contract.mighty;
                const masterIndex = this.gameState.contract.master;
                const round = this.gameState.round;
                const jokerCall = this.gameState.contract.jokerCall;

                const govScore = this.gameState.governmentScore;
                const bidValue = this.gameState.contract.bidValue;
                const pointsNeeded = bidValue - govScore;
                const remainingRounds = 10 - round + 1;
                const isGovernmentClose = pointsNeeded <= remainingRounds * 2;

                // ★ 야당 조커콜 전략
                const hasJokerCallCard = jokerCall && hand.some(c => c.equals(jokerCall));
                const isJokerStillOut = !this.gameState.jokerUsed;
                const iHaveJoker = hand.some(c => c.isJoker);

                // 변경 후
if (round >= 2 && round <= 9 && hasJokerCallCard && isJokerStillOut && !iHaveJoker) {
    // 사연 정보로 여당 조커 보유 여부 추정
    const sayeon = this.gameState.sayeonResponse;
    const sayeonUsed = this.gameState.settings?.useSayeon !== false;
    // 사연을 안 물었으면 주공이 조커 보유 추정
    const masterLikelyHasJoker = (sayeon === null && sayeonUsed);
    // 사연 응답이 '넌사'면 친구가 조커 보유
    const friendLikelyHasJoker = (sayeon === '넌사');
    // 여당이 조커를 가지고 있다면 조커콜로 빼내는 것이 유리
    const govHasJoker = masterLikelyHasJoker || friendLikelyHasJoker;

    const mightyPlayed = this.gameState.mightyUsed;
    if (mightyPlayed) {
        reasoning.push('조커콜 - 마이티 출현 후, 여당 조커 빼내기');
        return jokerCall;
    }
    if (govHasJoker && round >= 4) {
        reasoning.push('조커콜 - 사연 정보로 여당 조커 보유 확인, 빼내기');
        return jokerCall;
    }
    if (isGovernmentClose && round >= 5) {
        reasoning.push('조커콜 - 여당 공약 임박');
        return jokerCall;
    }
    if (round >= 7) {
        reasoning.push('조커콜 - 후반부');
        return jokerCall;
    }
}

                // ★★★ 마이티 소진 전략 ★★★
                if (!this.gameState.mightyUsed) {
                    const mighty = this.gameState.contract.mighty;
                    const mightySuit = mighty.suit;
                    const myMightySuitCards = getCardsOfSuit(hand, mightySuit);

                    if (myMightySuitCards.length > 0) {
                        const remainingMightySuit = this.gameState.getRemainingCardsOfSuit(mightySuit);
                        const otherMightySuitRemaining = remainingMightySuit.filter(c =>
                            !c.equals(mighty) && !myMightySuitCards.some(mc => mc.equals(c))
                        );

                        const masterVoidMightySuit = trackingSummary?.playerVoidSuits?.[masterIndex]
                            ? trackingSummary.playerVoidSuits[masterIndex].includes(mightySuit)
                            : false;

                        const shouldForceMighty = (
                            round >= 3 && (
                                otherMightySuitRemaining.length <= 3 ||
                                masterVoidMightySuit ||
                                round >= 6
                            )
                        );

                        if (shouldForceMighty) {
                            const nonPointMightySuit = myMightySuitCards.filter(c => !c.isPointCard());

                            if (nonPointMightySuit.length > 0) {
                                reasoning.push(`마이티 소진 전략 - ${SUIT_NAMES[mightySuit]} 비점수 카드 리드`);
                                return this.selectLowestCard(nonPointMightySuit);
                            }

                            const bossInMightySuit = myMightySuitCards.find(c => {
                                const analysis = this.gameState.getCardAnalysis(c);
                                return analysis.isBoss;
                            });

                            if (bossInMightySuit) {
                                reasoning.push(`마이티 소진 전략 - ${SUIT_NAMES[mightySuit]} 보스카드 리드`);
                                return bossInMightySuit;
                            }

                            if (round >= 7 && myMightySuitCards.length > 0) {
                                reasoning.push(`마이티 소진 전략 - 후반부 ${SUIT_NAMES[mightySuit]} 리드`);
                                return this.selectHighestCard(myMightySuitCards);
                            }
                        }
                    }
                }



                if (this.shouldPlayMighty(hand, trickAnalysis, teamContext, true, round, trackingSummary)) {
                    reasoning.push('마이티 리드 (야당 공격)'); return mighty;
                }

                if (isGovernmentClose) {
                    reasoning.push('여당 공약 임박 - 공격적 플레이');
                    const masterVoidSuits = trackingSummary?.playerVoidSuits?.[masterIndex]
                        ? new Set(trackingSummary.playerVoidSuits[masterIndex])
                        : (this.gameState.playerVoidSuits.get(masterIndex) || new Set());
                    for (const suit of masterVoidSuits) {
                        const suitCards = getCardsOfSuit(hand, suit);
                        if (suitCards.length > 0) {
                            reasoning.push(`주공 ${SUIT_NAMES[suit]} 없음 - 공략`);
                            return this.selectHighestCard(suitCards);
                        }
                    }
                }

                for (const suit of Object.values(SUITS)) {
                    if (suit === giruda) continue;
                    const suitCards = getCardsOfSuit(hand, suit);
                    const ace = suitCards.find(c => c.rank === 'A');
                    if (ace) { reasoning.push(`${SUIT_NAMES[suit]} A 리드`); return ace; }
                }

                const nonGirudaCards = playableCards.filter(c => !c.isJoker && c.suit !== giruda);
                if (nonGirudaCards.length > 0) {
                    reasoning.push('비기루다 낮은 카드 리드');
                    return this.selectLowestCard(nonGirudaCards);
                }
                return this.selectLowestCard(playableCards);
            }

            // ===== 여당 팔로우 전략 (분기점) =====
governmentFollowStrategy(hand, trickAnalysis, teamContext, reasoning, trackingSummary = null) {
    const isFriend = teamContext.myRole === ROLES.FRIEND;
    if (isFriend) {
        return this.friendFollowStrategy_gov(hand, trickAnalysis, teamContext, reasoning, trackingSummary);
    } else {
        return this.masterFollowStrategy_gov(hand, trickAnalysis, teamContext, reasoning, trackingSummary);
    }
}

// ===== 주공 팔로우 전략 =====
masterFollowStrategy_gov(hand, trickAnalysis, teamContext, reasoning, trackingSummary = null) {
    const { playableCards, isGovernmentWinning, isOppositionWinning,
        canWin, cardsToWin, pointsInTrick, hasOppositionRemaining, hasGovernmentRemaining } = trickAnalysis;
    const round = this.gameState.round;
    const mighty = this.gameState.contract.mighty;
    const joker = hand.find(c => c.isJoker);
    const giruda = this.gameState.contract.giruda;
    const leadSuit = this.gameState.trick.leadSuit;

    const normalCards = playableCards.filter(c => !c.isJoker && !c.equals(mighty));

    

    // ── 9라운드 조커 긴급 사용 ──
    if (round === 9 && joker) {
        const mightyInTrick = this.gameState.trick.cards.some(p => p.card.equals(mighty));
        if (!mightyInTrick) {
            if (isOppositionWinning) {
                reasoning.push('9라운드 조커 긴급 사용 - 야당 탈환');
                return joker;
            }
            if (isGovernmentWinning && hasOppositionRemaining) {
                const currentWinnerIdx = trickAnalysis.currentWinner;
                const winningPlay = this.gameState.trick.cards.find(p => p.player === currentWinnerIdx);
                const winningCard = winningPlay?.card;
                const isWinStrong = winningCard && (
                    winningCard.equals(mighty) ||
                    this.gameState.getCardAnalysis(winningCard).isBoss
                );
                if (!isWinStrong) {
                    reasoning.push('9라운드 조커 긴급 사용 - 승리 확정');
                    return joker;
                }
            }
        }
    }

    // ── 조커콜 상황 ──
    if (this.gameState.trick.jokerCalled) {
        reasoning.push('조커콜 상황');
        if (hasCard(hand, mighty)) { reasoning.push('마이티로 승리'); return mighty; }
        if (canWin && cardsToWin.length > 0) {
            const normalWin = cardsToWin.filter(c => !c.isJoker);
            if (normalWin.length > 0) { reasoning.push('트릭 확보'); return this.selectLowestCard(normalWin); }
        }
        return this.selectLowestNonPointCard(playableCards) || this.selectLowestCard(playableCards);
    }

    // ── 여당이 이기고 있음 ──
    if (isGovernmentWinning) {
        reasoning.push('주공 팔로우 - 아군 승리 중');

        const nonBossNonPoint = normalCards.filter(c =>
            !this.gameState.getCardAnalysis(c).isBoss && !c.isPointCard()
        );
        if (nonBossNonPoint.length > 0) return this.selectLowestCard(nonBossNonPoint);

        const nonBossPoint = normalCards.filter(c =>
            !this.gameState.getCardAnalysis(c).isBoss && c.isPointCard()
        );
        if (nonBossPoint.length > 0) return this.selectLowestCard(nonBossPoint);

        if (normalCards.length > 0) return this.selectLowestCard(normalCards);
        return this.selectLowestCard(playableCards);
    }

    // ── 야당이 이기고 있음 ──
    if (isOppositionWinning) {
        reasoning.push('주공 팔로우 - 야당 승리 중, 탈환 시도');

        // 야당 조커가 이기고 있는 경우
        const currentWinnerPlay = this.gameState.trick.cards.find(p => p.player === trickAnalysis.currentWinner);
        const currentWinningCard = currentWinnerPlay?.card;
        const isJokerWinning = currentWinningCard && currentWinningCard.isJoker
            && round >= 2 && round <= 9 && !this.gameState.trick.jokerCalled;

        if (isJokerWinning) {
            if (hasCard(hand, mighty)) {
                if (pointsInTrick >= 1 || !hasOppositionRemaining) {
                    reasoning.push('마이티로 조커 탈환');
                    return mighty;
                }
            }
            reasoning.push('조커 승리 - 탈환 불가, 손실 최소화');
            return this.selectLowestNonPointCard(playableCards) || this.selectLowestCard(playableCards);
        }

        // 마이티 사용 판단
        if (this.shouldPlayMighty(hand, trickAnalysis, teamContext, false, round, trackingSummary)) {
            reasoning.push('마이티로 탈환');
            return mighty;
        }

        // 조커 사용 판단
        const mightyInTrick = this.gameState.trick.cards.some(p => p.card.equals(mighty));
        if (joker && round >= 2 && round <= 9 && !mightyInTrick) {
            const jd = this.shouldPlayJoker(hand, trickAnalysis, teamContext, false, round, trackingSummary);
            if (jd.shouldPlay) { reasoning.push('조커로 탈환'); return joker; }
        }

        // 일반 카드로 탈환
        if (canWin && cardsToWin.length > 0) {
            if (pointsInTrick >= 1 || !hasOppositionRemaining) {
                reasoning.push('탈환');
                return this.selectLowestCard(cardsToWin);
            }
            if (hasGovernmentRemaining && pointsInTrick <= 1) {
                reasoning.push('친구에게 위임');
                return this.selectLowestNonPointCard(playableCards) || this.selectLowestCard(playableCards);
            }
            return this.selectLowestCard(cardsToWin);
        }

        reasoning.push('탈환 불가 - 손실 최소화');
        return this.selectLowestNonPointCard(playableCards) || this.selectLowestCard(playableCards);
    }

    // ── 미확정 ──
    if (canWin && pointsInTrick >= 1) {
        reasoning.push('미확정 + 점수 - 탈환');
        return this.selectLowestCard(cardsToWin);
    }
    reasoning.push('기본 - 낮은 카드');
    return this.selectLowestCard(playableCards);
}

// ===== 친구 팔로우 전략 =====
friendFollowStrategy_gov(hand, trickAnalysis, teamContext, reasoning, trackingSummary = null) {
    const { playableCards, isGovernmentWinning, isOppositionWinning,
        canWin, cardsToWin, pointsInTrick, hasOppositionRemaining, hasGovernmentRemaining } = trickAnalysis;
    const round = this.gameState.round;
    const mighty = this.gameState.contract.mighty;
    const joker = hand.find(c => c.isJoker);
    const giruda = this.gameState.contract.giruda;
    const leadSuit = this.gameState.trick.leadSuit;
    const masterIndex = this.gameState.contract.master;

    const normalCards = playableCards.filter(c => !c.isJoker && !c.equals(mighty));
    const safeCards = playableCards.filter(c => !c.isJoker && !c.equals(mighty));

    const leadPlayerIdx = this.gameState.trick.leadPlayer;
    const isMasterLead = (leadPlayerIdx === masterIndex);

    reasoning.push('친구 팔로우 전략');

    
    // ── 9라운드 조커 긴급 사용 ──
    if (round === 9 && joker) {
        const mightyInTrick = this.gameState.trick.cards.some(p => p.card.equals(mighty));
        if (!mightyInTrick) {
            if (isOppositionWinning) {
                reasoning.push('9라운드 조커 긴급 사용 - 야당 탈환');
                return joker;
            }
            if (isGovernmentWinning && hasOppositionRemaining) {
                const currentWinnerIdx = trickAnalysis.currentWinner;
                const winningPlay = this.gameState.trick.cards.find(p => p.player === currentWinnerIdx);
                const winningCard = winningPlay?.card;
                const isWinStrong = winningCard && (
                    winningCard.equals(mighty) ||
                    this.gameState.getCardAnalysis(winningCard).isBoss
                );
                if (!isWinStrong) {
                    reasoning.push('9라운드 조커 긴급 사용 - 승리 확정');
                    return joker;
                }
            }
        }
    }

    // ── 조커콜 상황 ──
    if (this.gameState.trick.jokerCalled) {
        reasoning.push('조커콜 상황');
        if (hasCard(hand, mighty)) { reasoning.push('마이티로 승리'); return mighty; }
        if (canWin && cardsToWin.length > 0) {
            const normalWin = cardsToWin.filter(c => !c.isJoker);
            if (normalWin.length > 0) { reasoning.push('트릭 확보'); return this.selectLowestCard(normalWin); }
        }
        return this.selectLowestNonPointCard(playableCards) || this.selectLowestCard(playableCards);
    }

    // ── 주공 조커 리드 시 점수 실어주기 ──
    const leadCard = this.gameState.trick.cards[0]?.card;
    if (leadCard?.isJoker && isMasterLead) {
        reasoning.push('주공 조커 리드 - 점수 실어주기');
        const nonBoss = normalCards.filter(c => !this.gameState.getCardAnalysis(c).isBoss);
        const nbPoint = nonBoss.filter(c => c.isPointCard());
        if (nbPoint.length > 0) return this.selectLowestCard(nbPoint);
        if (nonBoss.length > 0) return this.selectLowestCard(nonBoss);
        if (normalCards.length > 0) return this.selectLowestCard(normalCards);
        return this.selectLowestCard(playableCards);
    }

    // ══════════════════════════════════════
    // ★★★ 여당이 이기고 있음 ★★★
    // ══════════════════════════════════════
    if (isGovernmentWinning) {
        const currentWinner = trickAnalysis.currentWinner;
        const winningPlay = this.gameState.trick.cards.find(p => p.player === currentWinner);
        const winningCard = winningPlay?.card;

        // 승리 강도 판정
        let isWinCardBoss = false;
        if (winningCard && !winningCard.isJoker && !winningCard.equals(mighty)) {
            isWinCardBoss = this.gameState.getCardAnalysis(winningCard).isBoss;
        }
        let isStrong = winningCard && (
            winningCard.equals(mighty) ||
            (winningCard.isJoker && round >= 2 && round <= 9) ||
            isWinCardBoss
        );

        // 기루다 컷도 강한 승리로 판정
        if (!isStrong && winningCard && !winningCard.isJoker && !winningCard.equals(mighty)) {
            const isGirudaCut = giruda &&
                winningCard.suit === giruda &&
                leadSuit !== giruda;
            if (isGirudaCut) {
                isStrong = true;
                reasoning.push('기루다 컷 → 강한 승리로 판정');
            }
        }

        // ── 주공이 이기고 있을 때 ──
        // ── 주공이 이기고 있을 때 ──
if (currentWinner === masterIndex) {

    // Case 1: 야당이 모두 완료 → 안전하게 점수 실어주기
    if (!hasOppositionRemaining) {
        reasoning.push('주공 승리 + 야당 완료 - 점수 실어주기');

        // 비보스 점수 카드 실어주기
        const nonBossPoint = safeCards.filter(c =>
            !this.gameState.getCardAnalysis(c).isBoss && c.isPointCard()
        );
        if (nonBossPoint.length > 0) return this.selectHighestCard(nonBossPoint);

        // 점수 카드 없으면 낮은 카드
        const safeNonBossNonPoint = safeCards.filter(c =>
            !this.gameState.getCardAnalysis(c).isBoss && !c.isPointCard()
        );
        if (safeNonBossNonPoint.length > 0) return this.selectLowestCard(safeNonBossNonPoint);

        if (safeCards.length > 0) return this.selectLowestCard(safeCards);
        return this.selectLowestCard(playableCards);
    }

    // Case 2: 주공 승리 확실 (보스카드/마이티/조커) + 야당 남아있음
    if (isStrong) {
        reasoning.push('주공 승리 확실 - 비보스 점수 실어주기');

        // 확실한 승리이므로 비보스 점수 카드 실어주기
        const nonBossPoint = safeCards.filter(c =>
            !this.gameState.getCardAnalysis(c).isBoss && c.isPointCard()
        );
        if (nonBossPoint.length > 0) return this.selectHighestCard(nonBossPoint);

        // 점수 카드 없으면 낮은 카드
        const safeNonBossNonPoint = safeCards.filter(c =>
            !this.gameState.getCardAnalysis(c).isBoss && !c.isPointCard()
        );
        if (safeNonBossNonPoint.length > 0) return this.selectLowestCard(safeNonBossNonPoint);

        if (safeCards.length > 0) return this.selectLowestCard(safeCards);
        return this.selectLowestCard(playableCards);
    }

    // Case 3: 주공이 약한 카드로 이기고 있고 야당 남아있음
    // → 야당이 역전할 가능성 높음 → 적극적으로 오버간하여 확보
    if (hasOppositionRemaining) {
        reasoning.push('주공 약한 승리 + 야당 남음 - 적극 오버간');

        // 보스카드로 확실하게 이기기 (마이티/조커 제외)
        const bossWin = cardsToWin.filter(c =>
            !c.isJoker && !c.equals(mighty) && this.gameState.getCardAnalysis(c).isBoss
        );
        if (bossWin.length > 0) {
            reasoning.push('보스카드로 확실한 오버간');
            return this.selectLowestCard(bossWin);
        }

        // 보스카드 없으면 일반 카드로 오버간
        if (canWin && cardsToWin.length > 0) {
            const cheapWin = cardsToWin.filter(c => !c.isJoker && !c.equals(mighty));
            if (cheapWin.length > 0) {
                // 기루다 컷이 가능하면 기루다 컷
                const girudaCut = cheapWin.filter(c => giruda && c.suit === giruda && leadSuit !== giruda);
                if (girudaCut.length > 0) {
                    reasoning.push('기루다 컷으로 오버간');
                    return this.selectLowestCard(girudaCut);
                }
                reasoning.push('일반 오버간');
                return this.selectLowestCard(cheapWin);
            }
        }

        // 이길 수 없으면 비점수 낮은 카드 (점수 손실 방지)
        reasoning.push('오버간 불가 - 비점수 낮은 카드');
        const nonPoint = safeCards.filter(c => !c.isPointCard());
        if (nonPoint.length > 0) return this.selectLowestCard(nonPoint);
        if (safeCards.length > 0) return this.selectLowestCard(safeCards);
        return this.selectLowestCard(playableCards);
    }
}


        // ── 여당 승리 공통: 보스카드 보존, 낮은 카드 ──
        reasoning.push('여당 승리 - 보스카드 보존');
        const nonBossNonPoint = normalCards.filter(c =>
            !this.gameState.getCardAnalysis(c).isBoss && !c.isPointCard()
        );
        if (nonBossNonPoint.length > 0) return this.selectLowestCard(nonBossNonPoint);

        const nonBoss = normalCards.filter(c => !this.gameState.getCardAnalysis(c).isBoss);
        if (nonBoss.length > 0) return this.selectLowestCard(nonBoss);
        return this.selectLowestNonPointCard(normalCards) || this.selectLowestCard(playableCards);
    }

    // ══════════════════════════════════════
    // ★★★ 야당이 이기고 있음 ★★★
    // ══════════════════════════════════════
    if (isOppositionWinning) {
        const currentWinnerIdx = trickAnalysis.currentWinner;
        const currentWinPlay = this.gameState.trick.cards.find(p => p.player === currentWinnerIdx);
        const currentWinCard = currentWinPlay?.card;
        const pointsNeeded = this.gameState.contract.bidValue - this.gameState.governmentScore;

        // ── 주공이 리드했는데 야당이 역전한 상황 ──
        if (isMasterLead) {
            reasoning.push('주공 리드 - 야당 역전 → 탈환 시도');
            const mightyInTrick = this.gameState.trick.cards.some(p => p.card.equals(mighty));

            // 1순위: 일반 카드로 탈환
            if (canWin && cardsToWin.length > 0) {
                const cheapWin = cardsToWin.filter(c => !c.isJoker && !c.equals(mighty));
                if (cheapWin.length > 0) {
                    reasoning.push('일반 카드로 탈환');
                    return this.selectLowestCard(cheapWin);
                }
            }

            // 2순위: 조커로 탈환 (마이티보다 조커를 먼저 소모)
            if (joker && round >= 2 && round <= 9 && !mightyInTrick) {
                if (pointsInTrick >= 1 || round >= 7) {
                    reasoning.push('조커로 주공 지원 (마이티 보존)');
                    return joker;
                }
            }

            // 3순위: 마이티로 탈환 (조건부)
            if (hasCard(hand, mighty)) {
                const shouldUseMighty = (
                    pointsInTrick >= 3 ||
                    (pointsInTrick >= 2 && round >= 6) ||
                    (pointsInTrick >= 1 && round >= 8) ||
                    (pointsNeeded > 0 && round >= 9) ||
                    (pointsInTrick >= 2 && !hasOppositionRemaining)
                );
                if (shouldUseMighty) {
                    reasoning.push(`마이티로 주공 지원 (${pointsInTrick}점, R${round})`);
                    return mighty;
                } else {
                    reasoning.push(`마이티 보존 (${pointsInTrick}점 - 가치 부족)`);
                }
            }

            // 탈환 불가
            reasoning.push('탈환 불가 - 손실 최소화');
            return this.selectLowestNonPointCard(playableCards) || this.selectLowestCard(playableCards);
        }

        // ── 야당 리드에서 야당이 이기고 있는 상황 ──
        reasoning.push('야당 리드 - 야당 승리 중');

        // 야당 조커가 이기고 있는 경우
        const isJokerWinning = currentWinCard && currentWinCard.isJoker
            && round >= 2 && round <= 9 && !this.gameState.trick.jokerCalled;

        if (isJokerWinning) {
            if (hasCard(hand, mighty)) {
                if (pointsInTrick >= 2 || (pointsInTrick >= 1 && round >= 6) || !hasOppositionRemaining) {
                    reasoning.push('마이티로 조커 탈환');
                    return mighty;
                }
            }
            reasoning.push('조커 승리 - 탈환 불가, 손실 최소화');
            return this.selectLowestNonPointCard(playableCards) || this.selectLowestCard(playableCards);
        }

        // 조커 사용 판단 (마이티보다 먼저 검토)
        const mightyInTrick = this.gameState.trick.cards.some(p => p.card.equals(mighty));
        if (joker && round >= 2 && round <= 9 && !mightyInTrick) {
            if (pointsInTrick >= 2 || (pointsInTrick >= 1 && round >= 6)) {
                reasoning.push('조커로 탈환 (마이티 보존)');
                return joker;
            }
        }

        // 마이티 사용 판단 (강화된 조건)
        if (hasCard(hand, mighty)) {
            const shouldUseMighty = (
                pointsInTrick >= 3 ||
                (pointsInTrick >= 2 && round >= 7) ||
                (pointsInTrick >= 1 && round >= 9) ||
                (pointsNeeded > 0 && round >= 9 && pointsInTrick >= 1)
            );
            if (shouldUseMighty) {
                reasoning.push(`마이티로 탈환 (${pointsInTrick}점, R${round})`);
                return mighty;
            }
        }

        // 일반 카드로 탈환
        if (canWin && cardsToWin.length > 0) {
            const normalWin = cardsToWin.filter(c => !c.isJoker && !c.equals(mighty));
            if (normalWin.length > 0) {
                if (pointsInTrick >= 1 || !hasOppositionRemaining) {
                    reasoning.push('일반 카드로 탈환');
                    return this.selectLowestCard(normalWin);
                }
            }
            // 주공이 남아있으면 위임
            const isMasterRemaining = trickAnalysis.remainingPlayers.includes(masterIndex);
            if (isMasterRemaining && pointsInTrick <= 1) {
                reasoning.push('주공에게 위임');
                return this.selectLowestNonPointCard(playableCards) || this.selectLowestCard(playableCards);
            }
            if (normalWin.length > 0) return this.selectLowestCard(normalWin);
        }

        // 주공이 남아있으면 위임
        const isMasterRemaining = trickAnalysis.remainingPlayers.includes(masterIndex);
        if (isMasterRemaining) {
            reasoning.push('탈환 불가 - 주공에게 위임');
            return this.selectLowestNonPointCard(playableCards) || this.selectLowestCard(playableCards);
        }

        reasoning.push('탈환 불가 - 손실 최소화');
        return this.selectLowestNonPointCard(playableCards) || this.selectLowestCard(playableCards);
    }


    // ══════════════════════════════════════
    // ★★★ 미확정 상황 ★★★
    // ══════════════════════════════════════
    if (canWin && pointsInTrick >= 1) {
        reasoning.push('미확정 + 점수 - 확보 시도');
        const cheapWin = cardsToWin.filter(c => !c.isJoker && !c.equals(mighty));
        if (cheapWin.length > 0) return this.selectLowestCard(cheapWin);
        return this.selectLowestCard(cardsToWin);
    }
    reasoning.push('기본 - 낮은 카드 (마이티/조커 보존)');
    if (safeCards.length > 0) return this.selectLowestCard(safeCards);
    return this.selectLowestCard(playableCards);
}

            // ===== 야당 팔로우 전략 =====
            oppositionFollowStrategy(hand, trickAnalysis, teamContext, reasoning, trackingSummary = null) {
                const { playableCards, isGovernmentWinning, isOppositionWinning, isUncertain,
                    canWin, cardsToWin, pointsInTrick, hasGovernmentRemaining, hasOppositionRemaining } = trickAnalysis;
                const round = this.gameState.round;
                const mighty = this.gameState.contract.mighty;
                const joker = hand.find(c => c.isJoker);
                const giruda = this.gameState.contract.giruda;

                const nonBossCards = playableCards.filter(c => {
                    if (c.isJoker || c.equals(mighty)) return false;
                    return !this.gameState.getCardAnalysis(c).isBoss;
                });
                const nonBossNonPoint = nonBossCards.filter(c => !c.isPointCard());

                // 조커콜 상황
                if (this.gameState.trick.jokerCalled) {
                    reasoning.push('조커콜 상황');
                    if (canWin && cardsToWin.length > 0) {
                        reasoning.push('탈환 시도'); return this.selectLowestCard(cardsToWin);
                    }
                    return this.selectLowestNonPointCard(playableCards) || this.selectLowestCard(playableCards);
                }

                // 주공 조커 리드 시
                const leadCard = this.gameState.trick.cards[0]?.card;
                const leadPlayer = this.gameState.trick.cards[0]?.player;
                const masterIndex = this.gameState.contract.master;
                if (leadCard?.isJoker && leadPlayer === masterIndex && round >= 2 && round <= 9) {
                    reasoning.push('주공 조커 리드 - 손실 최소화');
                    const nonPointCards = playableCards.filter(c => !c.isPointCard());
                    if (nonPointCards.length > 0) return this.selectLowestCard(nonPointCards);
                    return this.selectLowestCard(playableCards);
                }
                // ★★★ 마이티 소진 협력 전략 ★★★
                if (!this.gameState.mightyUsed) {
                    const mighty = this.gameState.contract.mighty;
                    const mightySuit = mighty.suit;
                    const leadSuit = this.gameState.trick.leadSuit;

                    if (leadSuit === mightySuit) {
                        const leadPlayerIndex = this.gameState.trick.leadPlayer;
                        const isLeaderOpposition = teamContext.oppositionPlayers.includes(leadPlayerIndex);

                        if (isLeaderOpposition) {
                            reasoning.push('마이티 소진 협력 - 낮은 카드 (점수 아끼기)');

                            const mightySuitCards = playableCards.filter(c => !c.isJoker && c.suit === mightySuit);
                            const nonPointMightySuit = mightySuitCards.filter(c => !c.isPointCard());

                            if (nonPointMightySuit.length > 0) {
                                return this.selectLowestCard(nonPointMightySuit);
                            }

                            if (mightySuitCards.length === 0) {
                                const safeCards = playableCards.filter(c =>
                                    !c.isJoker && !c.isPointCard() && c.suit !== giruda
                                );
                                if (safeCards.length > 0) {
                                    return this.selectLowestCard(safeCards);
                                }
                            }

                            return this.selectLowestNonPointCard(playableCards) || this.selectLowestCard(playableCards);
                        }
                    }
                }


                if (isOppositionWinning) {
                    const currentWinner = trickAnalysis.currentWinner;
                    const winningPlay = this.gameState.trick.cards.find(p => p.player === currentWinner);
                    const winningCard = winningPlay?.card;

                    // ★ 승리 강도를 3단계로 분류
                    let isWinCardBoss = false;
                    if (winningCard && !winningCard.isJoker && !winningCard.equals(mighty)) {
                        isWinCardBoss = this.gameState.getCardAnalysis(winningCard).isBoss;
                    }

                    // 확정 승리: 뒤집을 수 없는 승리
                    // - 조커로 이기고 있음 (마이티만 이기지만, 마이티가 이미 나왔거나 이번 트릭에 없으면 확정)
                    // - 기루다 보스카드로 이기고 있음 (마이티/조커만 이김)
                    // - 여당이 모두 냈음
                    const mightyPlayedAlready = this.gameState.mightyUsed;
                    const mightyInTrick = this.gameState.trick.cards.some(p => p.card.equals(this.gameState.contract.mighty));
                    const isJokerWinning = winningCard && winningCard.isJoker && round >= 2 && round <= 9;
                    const isGirudaBossWinning = isWinCardBoss && winningCard && winningCard.suit === giruda;

                    const isConfirmedWin = !hasGovernmentRemaining || // 여당 다 냄
                        (isJokerWinning && (mightyPlayedAlready || mightyInTrick)) || // 조커 승리 + 마이티 없음
                        isGirudaBossWinning; // 기루다 보스카드

                    // 높은 확률 승리: 뒤집힐 가능성이 낮은 승리
                    // - 조커로 이기고 있음 (마이티 위험 있지만 확률 낮음)
                    // - 비기루다 보스카드로 이기고 있음 (기루다 컷 가능성 있지만)
                    // - 기루다로 이기고 있음 (보스카드 아니어도 높은 카드)
                    const isLikelyWin = isConfirmedWin ||
                        isJokerWinning || // 조커 승리 (마이티 위험 있어도)
                        isWinCardBoss || // 아무 수트의 보스카드
                        (winningCard && !winningCard.isJoker && winningCard.suit === giruda &&
                            RANK_VALUES[winningCard.rank] >= 12); // 기루다 Q 이상

                    // 전체 점수 카드 (마이티/조커 제외)
                    const allPointCards = playableCards.filter(c => c.isPointCard() && !c.isJoker && !c.equals(mighty));
                    // 보스카드인 점수 카드
                    const bossPointCards = allPointCards.filter(c => this.gameState.getCardAnalysis(c).isBoss);
                    // 비보스 점수 카드
                    const nonBossPointCards2 = allPointCards.filter(c => !this.gameState.getCardAnalysis(c).isBoss);

                    // ★★★ 확정 승리: 모든 점수 카드 적극 실어주기 (보스카드 포함) ★★★
                    if (isConfirmedWin) {
                        reasoning.push(`확정 승리(${winningCard?.toString()}) - 점수 최대 실어주기`);

                        // 비보스 점수 카드 먼저 (보스카드는 가능하면 아끼지만, 없으면 보스카드도 실어줌)
                        if (nonBossPointCards2.length > 0) {
                            return this.selectHighestCard(nonBossPointCards2);
                        }
                        // 비보스가 없으면 보스카드 점수도 실어주기
                        // ★ 야당은 리드 기회가 적으므로, 확정 승리에 점수를 몰아주는 것이 유리
                        if (bossPointCards.length > 0) {
                            // 단, 기루다 보스카드는 보존 (기루다 보스카드는 직접 리드해서 이기는 것이 더 가치 있음)
                            const nonGirudaBossPoint = bossPointCards.filter(c => c.suit !== giruda);
                            if (nonGirudaBossPoint.length > 0) {
                                reasoning.push('확정 승리 - 비기루다 보스카드 점수도 실어주기');
                                return this.selectHighestCard(nonGirudaBossPoint);
                            }
                            // 기루다 보스카드 점수밖에 없으면 고민
                            // 남은 라운드가 적으면(7라운드 이후) 실어주기, 아니면 보존
                            if (round >= 7) {
                                reasoning.push('후반부 확정 승리 - 기루다 보스카드 점수도 실어주기');
                                return this.selectHighestCard(bossPointCards);
                            }
                        }

                        // 점수 카드가 없으면 낮은 카드
                        if (nonBossNonPoint.length > 0) return this.selectLowestCard(nonBossNonPoint);
                        if (nonBossCards.length > 0) return this.selectLowestCard(nonBossCards);
                        return this.selectLowestCard(playableCards);
                    }

                    // ★★★ 높은 확률 승리: 비보스 점수 카드 실어주기 + 상황에 따라 보스카드도 ★★★
                    if (isLikelyWin) {
                        reasoning.push(`유력 승리(${winningCard?.toString()}) - 점수 실어주기`);

                        // 비보스 점수 카드 실어주기
                        if (nonBossPointCards2.length > 0) {
                            return this.selectHighestCard(nonBossPointCards2);
                        }

                        // 비보스 점수 카드가 없을 때:
                        // 남은 여당이 있으면 보스카드는 보존 (역전 가능성)
                        // 남은 여당이 없으면 보스카드도 실어주기
                        if (!hasGovernmentRemaining && bossPointCards.length > 0) {
                            const nonGirudaBossPoint = bossPointCards.filter(c => c.suit !== giruda);
                            if (nonGirudaBossPoint.length > 0) {
                                reasoning.push('여당 완료 - 비기루다 보스카드 점수 실어주기');
                                return this.selectHighestCard(nonGirudaBossPoint);
                            }
                        }

                        // ★ 리드 기회가 거의 없는 후반부(8라운드 이후)에는 보스카드도 실어주기
                        if (round >= 8 && bossPointCards.length > 0) {
                            reasoning.push('후반부 - 보스카드 점수도 실어주기 (리드 기회 부족)');
                            return this.selectHighestCard(bossPointCards);
                        }

                        // 점수 카드가 없으면 낮은 카드
                        if (nonBossNonPoint.length > 0) return this.selectLowestCard(nonBossNonPoint);
                        if (nonBossCards.length > 0) return this.selectLowestCard(nonBossCards);
                        return this.selectLowestCard(playableCards);
                    }

                    // ★★★ 불확실한 승리: 여당이 아직 남아있고 역전 가능성 있음 ★★★
                    if (hasGovernmentRemaining) {
                        reasoning.push('불확실 승리 + 여당 남음 - 보스카드 보존');

                        // 비보스 비점수 카드로 방어
                        if (nonBossNonPoint.length > 0) return this.selectLowestCard(nonBossNonPoint);

                        // 비보스 카드 (점수 카드도 포함될 수 있지만 보스카드보다 나음)
                        if (nonBossCards.length > 0) return this.selectLowestCard(nonBossCards);

                        // 보스카드밖에 없으면 비점수 보스카드 우선
                        const bossNonPoint = playableCards.filter(c =>
                            !c.isPointCard() && !c.isJoker && !c.equals(mighty)
                        );
                        if (bossNonPoint.length > 0) return this.selectLowestCard(bossNonPoint);

                        return this.selectLowestNonPointCard(playableCards) || this.selectLowestCard(playableCards);
                    }

                    // 여당이 없고 위 조건에 안 걸린 경우 (일반적으로 도달하지 않음)
                    reasoning.push('아군 승리 - 낮은 카드');
                    if (nonBossNonPoint.length > 0) return this.selectLowestCard(nonBossNonPoint);
                    if (nonBossCards.length > 0) return this.selectLowestCard(nonBossCards);
                    return this.selectLowestCard(playableCards);
                }

                if (isGovernmentWinning) {
                    if (this.shouldPlayMighty(hand, trickAnalysis, teamContext, false, round, trackingSummary)) {
                        reasoning.push('마이티로 탈환'); return mighty;
                    }

                    const mightyInTrick = this.gameState.trick.cards.some(p => p.card.equals(mighty));
                    const mightyPlayed = this.gameState.mightyUsed;
                    if (joker && round >= 2 && round <= 9 && !mightyInTrick) {
                        if (!mightyPlayed && hasGovernmentRemaining) {
                            if (pointsInTrick >= 2 || round >= 2) { reasoning.push('조커로 탈환'); return joker; }
                        } else {
                            const jd = this.shouldPlayJoker(hand, trickAnalysis, teamContext, false, round, trackingSummary);
                            if (jd.shouldPlay) { reasoning.push('조커로 탈환'); return joker; }
                        }
                    }

                    if (canWin && cardsToWin.length > 0) {
                        if (!hasGovernmentRemaining || pointsInTrick >= 2) {
                            reasoning.push('탈환'); return this.selectLowestCard(cardsToWin);
                        }
                        if (hasOppositionRemaining && pointsInTrick <= 1) {
                            const lowestWin = this.selectLowestCard(cardsToWin);
                            const str = lowestWin.isJoker ? 100 : RANK_VALUES[lowestWin.rank];
                            if (str >= 11) {
                                reasoning.push('동료에게 위임');
                                if (nonBossNonPoint.length > 0) return this.selectLowestCard(nonBossNonPoint);
                                if (nonBossCards.length > 0) return this.selectLowestCard(nonBossCards);
                                return this.selectLowestNonPointCard(playableCards) || this.selectLowestCard(playableCards);
                            }
                        }
                        reasoning.push('탈환'); return this.selectLowestCard(cardsToWin);
                    }

                    reasoning.push('손실 최소화');
                    if (nonBossNonPoint.length > 0) return this.selectLowestCard(nonBossNonPoint);
                    if (nonBossCards.length > 0) return this.selectLowestCard(nonBossCards);
                    return this.selectLowestNonPointCard(playableCards) || this.selectLowestCard(playableCards);
                }

                // 미확정
                if (canWin && pointsInTrick >= 1) {
                    reasoning.push('미확정 + 점수 - 탈환');
                    return this.selectLowestCard(cardsToWin);
                }
                reasoning.push('기본 - 낮은 카드');
                return this.selectLowestNonPointCard(playableCards) || this.selectLowestCard(playableCards);
            }

            // ===== 조커 수트 선언 =====
            selectJokerCallSuit(hand, teamContext) {
                const giruda = this.gameState.contract.giruda;
                const isGovernment = teamContext.myRole === ROLES.MASTER || teamContext.myRole === ROLES.FRIEND;
                const isNoGiruda = this.gameState.contract.isNoGiruda;

                if (isGovernment) {
                    if (!isNoGiruda && giruda) {
                        const remainingGiruda = this.gameState.getRemainingCardsOfSuit(giruda);
                        const myGiruda = getCardsOfSuit(hand, giruda);
                        const oppGiruda = remainingGiruda.filter(c => !myGiruda.some(mc => mc.equals(c)));
                        if (oppGiruda.length > 0) return giruda;
                    }
                    const suitPointCounts = {};
                    for (const suit of Object.values(SUITS)) {
                        if (suit === giruda) continue;
                        const remaining = this.gameState.getRemainingCardsOfSuit(suit);
                        const pointCards = remaining.filter(c => c.isPointCard());
                        const myCards = getCardsOfSuit(hand, suit);
                        suitPointCounts[suit] = myCards.length === 0 ? pointCards.length + 5 : pointCards.length;
                    }
                    let bestSuit = null;
                    let maxPoints = -1;
                    for (const [suit, points] of Object.entries(suitPointCounts)) {
                        if (points > maxPoints) { maxPoints = points; bestSuit = suit; }
                    }
                    if (bestSuit) return bestSuit;
                }

                if (!isGovernment) {
                    const masterVoidSuits = this.gameState.playerVoidSuits.get(this.gameState.contract.master);
                    if (masterVoidSuits && masterVoidSuits.size > 0) {
                        for (const suit of masterVoidSuits) return suit;
                    }
                }

                for (const suit of [SUITS.SPADE, SUITS.DIAMOND, SUITS.HEART, SUITS.CLUB]) {
                    if (suit === giruda) continue;
                    if (getCardsOfSuit(hand, suit).length === 0) return suit;
                }
                return giruda !== SUITS.SPADE ? SUITS.SPADE : SUITS.DIAMOND;
            }

            // ===== 유틸리티 =====
            selectHighestCard(cards) {
                if (cards.length === 0) return null;
                return cards.reduce((h, c) => {
                    if (c.isJoker) return h;
                    if (!h || h.isJoker) return c;
                    return RANK_VALUES[c.rank] > RANK_VALUES[h.rank] ? c : h;
                });
            }

            selectLowestCard(cards) {
                if (cards.length === 0) return null;
                return cards.reduce((l, c) => {
                    if (c.isJoker) return (c.isJoker && !l) ? c : l;
                    if (!l) return c;
                    if (l.isJoker) return c;
                    return RANK_VALUES[c.rank] < RANK_VALUES[l.rank] ? c : l;
                });
            }

            selectLowestNonPointCard(cards) {
                const nonPoint = cards.filter(c => !c.isPointCard());
                if (nonPoint.length === 0) return null;
                return this.selectLowestCard(nonPoint);
            }

            findLongestSuit(hand, excludeSuit = null) {
                let longest = null;
                let maxCount = 0;
                for (const suit of Object.values(SUITS)) {
                    if (suit === excludeSuit) continue;
                    const count = getCardsOfSuit(hand, suit).length;
                    if (count > maxCount) { maxCount = count; longest = suit; }
                }
                return longest;
            }
        }
        // ========================================
        // ===== ui.js =====
        // ========================================

        class UI {
            constructor(gameState, settings) {
                this.gameState = gameState;
                this.settings = settings;
                this.isMobile = document.body.classList.contains('mobile-mode');
                this.selectedCards = [];
                this.selectedBid = { value: null, suit: null };
                this.selectedFriend = { suit: null, rank: null };
                this.initializeEventListeners();
            }

            initializeEventListeners() {
                document.getElementById('test-mode-toggle').addEventListener('click', () => {
                    this.settings.showAICards = !this.settings.showAICards;
                    this.settings.showAILog = this.settings.showAICards;
                    this.settings.highlightPlayable = this.settings.showAICards;
                    this.updateTestModeButton();
                    this.renderAll();
                });

                document.getElementById('settings-btn').addEventListener('click', () => this.showSettingsModal());
                document.getElementById('settings-close').addEventListener('click', () => this.hideSettingsModal());

                document.getElementById('setting-show-ai-cards').addEventListener('change', (e) => {
                    this.settings.showAICards = e.target.checked; this.renderAll();
                });
                document.getElementById('setting-show-ai-log').addEventListener('change', (e) => {
                    this.settings.showAILog = e.target.checked; this.renderAILog();
                });
                document.getElementById('setting-highlight-playable').addEventListener('change', (e) => {
                    this.settings.highlightPlayable = e.target.checked; this.renderAll();
                });
                document.getElementById('setting-ai-speed').addEventListener('change', (e) => {
                    this.settings.aiSpeed = parseInt(e.target.value);
                });
                document.getElementById('setting-use-sayeon').addEventListener('change', (e) => {
                    this.settings.useSayeon = e.target.checked;
                });

                document.getElementById('log-toggle').addEventListener('click', () => {
                    document.getElementById('ai-log-panel').classList.toggle('collapsed');
                    const btn = document.getElementById('log-toggle');
                    btn.textContent = btn.textContent === '▼' ? '▶' : '▼';
                });

                document.getElementById('new-game-btn').addEventListener('click', () => {
                    this.hideResultModal();
                    if (this.onNewGame) this.onNewGame();
                });
                document.getElementById('end-game-btn').addEventListener('click', () => {
                    this.hideResultModal();
                    if (this.onEndGame) this.onEndGame();
                });

                // ★ 키보드 단축키
                document.addEventListener('keydown', (e) => {
                    if (e.key === 'Escape') {
                        this.hideBiddingModal();
                        this.hideFriendModal();
                        this.hideExchangeModal();
                        this.hideJokerCallModal();
                        this.hideSettingsModal();
                    }
                    if ((e.key === 'p' || e.key === 'P') &&
                        this.gameState.phase === PHASES.BIDDING &&
                        this.gameState.currentTurn === 0 &&
                        !document.getElementById('bidding-modal').classList.contains('hidden')) {
                        this.passBid();
                    }
                    if (this.gameState.phase === PHASES.PLAYING && this.gameState.currentTurn === 0) {
                        const keyNum = parseInt(e.key);
                        if (!isNaN(keyNum)) {
                            const player = this.gameState.players[0];
                            const sortedHand = sortCards(player.hand, this.gameState.contract.giruda, this.gameState.contract.mighty);
                            const idx = keyNum === 0 ? 9 : keyNum - 1;
                            if (idx < sortedHand.length) this.onCardClick(sortedHand[idx]);
                        }
                    }
                });
            }

            updateTestModeButton() {
                const btn = document.getElementById('test-mode-toggle');
                if (this.settings.showAICards) {
                    btn.classList.add('active');
                    btn.textContent = '🔧 테스트모드 ON';
                } else {
                    btn.classList.remove('active');
                    btn.textContent = '🔧 테스트모드 OFF';
                }
            }
            renderMobileGirudaBg() {
                const el = document.getElementById('mobile-giruda-bg');
                if (!el || !document.body.classList.contains('mobile-mode')) return;

                const contract = this.gameState.contract;
                if (!contract.bidValue ||
                    this.gameState.phase === PHASES.WAITING ||
                    this.gameState.phase === PHASES.BIDDING) {
                    el.style.display = 'none';
                    return;
                }

                el.style.display = 'block';

                if (contract.isNoGiruda) {
                    el.textContent = 'No';
                    el.style.color = 'rgba(158, 158, 158, 0.7)';
                    el.style.fontSize = '80px';
                } else if (contract.giruda) {
                    el.textContent = SUIT_SYMBOLS[contract.giruda];
                    const isRed = contract.giruda === SUITS.DIAMOND || contract.giruda === SUITS.HEART;
                    el.style.color = isRed ? 'rgba(211, 47, 47, 0.7)' : 'rgba(255, 255, 255, 0.6)';
                    el.style.fontSize = '120px';

                } else {
                    el.style.display = 'none';
                }
            }
            renderMobileScoreProgress() {
    if (!document.body.classList.contains('mobile-mode')) return;
    const container = document.getElementById('mobile-score-progress');
    if (!container) return;

    const contract = this.gameState.contract;
    if (!contract.bidValue ||
        this.gameState.phase === PHASES.WAITING ||
        this.gameState.phase === PHASES.BIDDING ||
        this.gameState.phase === PHASES.DEALING) {
        container.innerHTML = '';
        container.style.display = 'none';
        return;
    }

    container.style.display = '';

    const govScore = this.gameState.governmentScore;
    const oppScore = this.gameState.oppositionScore;
    const bidValue = contract.bidValue;
    const totalPoints = GAME_CONFIG.TOTAL_POINTS;

    container.innerHTML = `
        <span class="score-label government">여당 ${govScore}/${bidValue}</span>
        <div class="score-bar">
            <div class="score-bar-fill government" style="width: ${(govScore / totalPoints) * 100}%"></div>
        </div>
        <div class="score-bar">
            <div class="score-bar-fill opposition" style="width: ${(oppScore / totalPoints) * 100}%"></div>
        </div>
        <span class="score-label opposition">야당 ${oppScore}</span>
    `;
}


renderAll(options = {}) {
    if (!document.body.classList.contains('mobile-mode')) {
        const mg = document.getElementById('mobile-ai-grid');
        if (mg) mg.style.display = 'none';
        const mc = document.getElementById('mobile-center-area');
        if (mc) mc.style.display = 'none';
    }
    this.renderInfoBar();
    this.renderPlayers(options);
    this.renderTrick();
    this.renderGirudaBackground();
    this.renderScoreProgress();
    this.renderMobileAIGrid();
    this.renderMobileUserTrick();
    this.renderMobileScoreProgress();
    this.renderMobileGirudaBg();
    this.renderAILog();
}




            renderInfoBar() {
                document.getElementById('round-info').textContent = `라운드: ${this.gameState.round || '-'}/10`;
                const contract = this.gameState.contract;
                if (contract.bidValue) {
                    const suitSymbol = contract.isNoGiruda ? 'No' : (contract.giruda ? SUIT_SYMBOLS[contract.giruda] : '-');
                    document.getElementById('contract-info').textContent = `공약: ${contract.bidValue}${suitSymbol}`;
                    let friendText = '?';
                    if (contract.isNoFriend) friendText = '노프렌드';
                    else if (contract.friendCard) {
                        friendText = this.gameState.friendRevealed
                            ? `${contract.friendCard.toString()} (공개)`
                            : contract.friendCard.toString();
                    }
                    document.getElementById('friend-card-info').textContent = `친구: ${friendText}`;
                } else {
                    document.getElementById('contract-info').textContent = '공약: -';
                    document.getElementById('friend-card-info').textContent = '친구: ?';
                }
            }

            renderPlayers(options = {}) {
                for (let i = 0; i < GAME_CONFIG.PLAYER_COUNT; i++) this.renderPlayer(i, options);
            }

            renderPlayer(playerIndex, options = {}) {
                const player = this.gameState.players[playerIndex];
                const element = document.getElementById(`player-${playerIndex}`);
                const handElement = element.querySelector('.player-hand');
                const roleElement = element.querySelector('.player-role');
                const scoreElement = element.querySelector('.player-score span');

                element.classList.toggle('active-turn', this.gameState.currentTurn === playerIndex);

                roleElement.textContent = player.getRoleText();
                roleElement.className = 'player-role';
                if (player.role === ROLES.MASTER) { roleElement.classList.add('master'); roleElement.textContent = '주공 ★'; }
                else if (player.role === ROLES.FRIEND) { roleElement.classList.add('friend'); roleElement.textContent = '친구 ◆'; }
                else if (player.role === ROLES.OPPOSITION) { roleElement.classList.add('opposition'); }

                scoreElement.textContent = player.getScore();
                // 모바일 유저: 헤더에 점수 인라인 표시
                if (this.isMobile && playerIndex === 0) {
                    const header = element.querySelector('.player-header');
                    let inlineScore = header.querySelector('.inline-score');
                    if (!inlineScore) {
                        inlineScore = document.createElement('span');
                        inlineScore.className = 'inline-score';
                        inlineScore.style.cssText = 'font-size:11px;color:#FFD700;';
                        header.insertBefore(inlineScore, header.firstChild);
                    }
                    inlineScore.textContent = `점수: ${player.getScore()}점`;
                }
                handElement.innerHTML = '';

                let playableCards = [];
                if (this.gameState.phase === PHASES.PLAYING && this.gameState.currentTurn === playerIndex) {
                    const mightyPlayedInTrick = this.gameState.trick.cards.some(
                        p => p.card.equals(this.gameState.contract.mighty)
                    );
                    const isFirstRoundLead = (this.gameState.round === 1
                        && this.gameState.trick.cards.length === 0
                        && playerIndex === this.gameState.contract.master);

                    playableCards = getPlayableCards(player.hand, this.gameState.trick.leadSuit, this.gameState.round, {
                        mighty: this.gameState.contract.mighty,
                        jokerCalled: this.gameState.trick.jokerCalled,
                        mightyPlayedInTrick,
                        isFirstRoundLead,
                        giruda: this.gameState.contract.giruda
                    });
                }


                const sortedHand = sortCards(player.hand, this.gameState.contract.giruda, this.gameState.contract.mighty);

                sortedHand.forEach((card, index) => {
                    const cardEl = this.createCardElement(card, {
                        faceUp: player.isHuman || this.settings.showAICards,
                        isPlayable: playableCards.some(c => c.equals(card)),
                        showHighlight: this.settings.highlightPlayable && !player.isHuman && this.gameState.currentTurn === playerIndex,
                        isSpecial: this.isSpecialCard(card)
                    });

                    // ★ Deal Animation
                    if (options.animation === 'deal') {
                        cardEl.style.animation = `dealCard 0.3s ease-out backwards`;
                        cardEl.style.animationDelay = `${index * 0.05}s`;
                    }

                    if (player.isHuman && this.gameState.phase === PHASES.PLAYING && this.gameState.currentTurn === 0) {
                        const isPlayable = playableCards.some(c => c.equals(card));
                        if (isPlayable) {
                            cardEl.classList.add('playable');
                            cardEl.addEventListener('click', () => this.onCardClick(card));
                        } else {
                            cardEl.classList.add('dimmed');
                        }
                    }
                    handElement.appendChild(cardEl);
                });
            }

            createCardElement(card, options = {}) {
                const { faceUp = true, isPlayable = false, showHighlight = false, isSpecial = false } = options;
                const cardEl = document.createElement('div');
                cardEl.className = 'card';

                if (faceUp) {
                    cardEl.classList.add('face-up');
                    if (card.isJoker) {
                        cardEl.classList.add('joker');
                        const img = document.createElement('img');
                        img.src = JOKER_IMAGE; img.className = 'joker-image'; img.alt = 'Joker'; img.draggable = false;
                        cardEl.appendChild(img);
                    } else {
                        const imageUrl = getCardImageUrl(card.suit, card.rank);
                        if (imageUrl) {
                            const img = document.createElement('img');
                            img.src = imageUrl; img.className = 'card-image'; img.alt = `${card.rank} of ${card.suit}`; img.draggable = false;
                            cardEl.appendChild(img);
                        }
                    }
                    if (isSpecial) {
                        const label = this.getSpecialLabel(card);
                        if (label) {
                            const labelEl = document.createElement('span');
                            labelEl.className = 'special-label'; labelEl.textContent = label;
                            cardEl.appendChild(labelEl);
                        }
                    }
                    if (showHighlight && isPlayable) cardEl.classList.add('highlighted');
                    else if (showHighlight && !isPlayable) cardEl.classList.add('dimmed');
                } else {
                    cardEl.classList.add('face-down');
                }
                return cardEl;
            }

            isSpecialCard(card) {
                const { mighty, jokerCall, friendCard } = this.gameState.contract;
                return card.isJoker || (mighty && card.equals(mighty)) || (jokerCall && card.equals(jokerCall)) || (friendCard && card.equals(friendCard));
            }

            getSpecialLabel(card) {
                const { mighty, jokerCall, friendCard } = this.gameState.contract;
                if (mighty && card.equals(mighty)) return '마이티';
                if (card.isJoker) return '조커';
                if (jokerCall && card.equals(jokerCall)) return '조커콜';
                if (friendCard && card.equals(friendCard)) return '친구';
                return null;
            }

            // ★ 개선: 실시간 승자 표시
            renderTrick() {
                const trickCards = this.gameState.trick.cards;
                const isComplete = trickCards.length === GAME_CONFIG.PLAYER_COUNT;
                const { winner, winningCard } = trickCards.length > 0
                    ? this.gameState.determineTrickWinner()
                    : { winner: null, winningCard: null };

                for (let i = 0; i < GAME_CONFIG.PLAYER_COUNT; i++) {
                    const trickCardEl = document.querySelector(`.trick-card[data-player="${i}"]`);
                    trickCardEl.innerHTML = '';
                    trickCardEl.classList.remove('winner');
                    const play = trickCards.find(p => p.player === i);
                    if (play) {
                        const cardEl = this.createCardElement(play.card, { faceUp: true });
                        trickCardEl.appendChild(cardEl);
                        if (winner === i) trickCardEl.classList.add('winner');
                    }
                }

                const infoEl = document.getElementById('trick-info');
                if (trickCards.length > 0) {
                    const leadSuit = this.gameState.trick.leadSuit;
                    const points = trickCards.reduce((sum, p) => sum + (p.card.isPointCard() ? 1 : 0), 0);
                    let infoText = `리드: ${SUIT_NAMES[leadSuit] || '조커'} | 점수: ${points}점`;
                    if (winner !== null && !isComplete) {
                        infoText += ` | 현재 승자: ${this.gameState.players[winner].name}`;
                    }
                    if (this.gameState.trick.jokerCalled) infoText += ' | 🃏 조커콜!';
                    infoEl.textContent = infoText;
                } else {
                    infoEl.textContent = '';
                }
                this.renderMobileAIGrid();
                this.renderMobileUserTrick();
            }

            clearTrick() {
                for (let i = 0; i < GAME_CONFIG.PLAYER_COUNT; i++) {
                    const el = document.querySelector(`.trick-card[data-player="${i}"]`);
                    el.innerHTML = ''; el.classList.remove('winner');
                }
                document.getElementById('trick-info').textContent = '';
            }

            // ★ 팀별 점수 진행 바
            renderGirudaBackground() {
    const existing = document.getElementById('giruda-bg-symbol');
    if (existing) existing.remove();

    const contract = this.gameState.contract;
    if (!contract.bidValue || this.gameState.phase === PHASES.WAITING || this.gameState.phase === PHASES.BIDDING) return;

    const trickArea = document.getElementById('trick-area');
    const symbol = document.createElement('div');
    symbol.id = 'giruda-bg-symbol';

    let girudaText = '';
    let girudaColor = '';
    if (contract.isNoGiruda) {
        girudaText = 'No';
        girudaColor = 'rgba(158, 158, 158, 0.35)';

    } else if (contract.giruda) {
        girudaText = SUIT_SYMBOLS[contract.giruda];
        const isRed = contract.giruda === SUITS.DIAMOND || contract.giruda === SUITS.HEART;
        girudaColor = isRed ? 'rgba(211, 47, 47, 0.35)' : 'rgba(255, 255, 255, 0.3)';

    } else {
        return;
    }

    symbol.textContent = girudaText;
    symbol.style.cssText = `position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);font-size:180px;color:${girudaColor};pointer-events:none;z-index:0;font-weight:bold;line-height:1;`;
    trickArea.style.position = 'relative';
    trickArea.insertBefore(symbol, trickArea.firstChild);
}
            renderScoreProgress() {
                const existing = document.getElementById('score-progress');
                if (existing) existing.remove();

                const contract = this.gameState.contract;
                if (!contract.bidValue || this.gameState.phase === PHASES.WAITING || this.gameState.phase === PHASES.BIDDING) return;

                const govScore = this.gameState.governmentScore;
                const oppScore = this.gameState.oppositionScore;
                const bidValue = contract.bidValue;
                const totalPoints = GAME_CONFIG.TOTAL_POINTS;
                const trickInfo = document.getElementById('trick-info');

                const div = document.createElement('div');
                div.id = 'score-progress';
                div.className = 'score-progress';
                div.innerHTML = `
            <span class="score-label government">여당: ${govScore}/${bidValue}</span>
            <div class="score-bar">
                <div class="score-bar-fill government" style="width: ${(govScore / totalPoints) * 100}%"></div>
            </div>
            <div class="score-bar">
                <div class="score-bar-fill opposition" style="width: ${(oppScore / totalPoints) * 100}%"></div>
            </div>
            <span class="score-label opposition">야당: ${oppScore}</span>
        `;
                trickInfo.parentNode.insertBefore(div, trickInfo.nextSibling);
            }

            renderMobileAIGrid() {
                const grid = document.getElementById('mobile-ai-grid');
                if (!grid) return;
                if (!document.body.classList.contains('mobile-mode')) {
                    grid.style.display = 'none';
                    return;
                }
                grid.style.display = '';

    for (let i = 1; i <= 4; i++) {
        const player = this.gameState.players[i];
        const cell = grid.querySelector(`.mobile-ai-cell[data-ai="${i}"]`);
        if (!cell) continue;

        // 활성 턴 표시
        cell.classList.toggle('active-turn-cell', this.gameState.currentTurn === i);

        // 이름
        cell.querySelector('.cell-name').textContent = player.name;

        // 역할
        const roleEl = cell.querySelector('.cell-role');
        roleEl.textContent = '';
        roleEl.className = 'cell-role';
        if (player.role === ROLES.MASTER) {
            roleEl.textContent = '주공';
            roleEl.classList.add('master');
        } else if (player.role === ROLES.FRIEND && this.gameState.friendRevealed) {
            roleEl.textContent = '친구';
            roleEl.classList.add('friend');
        } else if (player.role === ROLES.OPPOSITION) {
            roleEl.textContent = '야당';
            roleEl.classList.add('opposition');
        }

        // 점수, 카드 수
        cell.querySelector('.cell-score').textContent = `${player.getScore()}점`;

        // 비딩 말풍선
        const bidBubble = cell.querySelector('.cell-bid-bubble');
        if (this.gameState.phase === PHASES.BIDDING) {
            bidBubble.style.display = '';
            const lastBid = [...this.gameState.bidding.history]
                .reverse()
                .find(h => h.player === i);
            if (lastBid) {
                if (lastBid.type === 'pass') {
                    bidBubble.textContent = '패스';
                    bidBubble.style.color = '#888';
                } else {
                    const sym = lastBid.suit === 'none' ? 'No' : SUIT_SYMBOLS[lastBid.suit];
                    bidBubble.textContent = `${lastBid.value}${sym}`;
                    bidBubble.style.color = '#FFD700';
                }
            } else {
                bidBubble.textContent = '대기';
                bidBubble.style.color = '#666';
            }
        } else {
            bidBubble.style.display = 'none';
        }

        // 트릭 카드 표시
        const trickCardArea = cell.querySelector('.cell-trick-card');
        trickCardArea.innerHTML = '';
        trickCardArea.classList.remove('winner');

        if (this.gameState.phase === PHASES.PLAYING ||
            this.gameState.phase === PHASES.TRICK_END) {
            const play = this.gameState.trick.cards.find(p => p.player === i);
            if (play) {
                const cardEl = this.createCardElement(play.card, { faceUp: true });
                trickCardArea.appendChild(cardEl);

                // 현재 승자 표시
                if (this.gameState.trick.cards.length > 0) {
                    const { winner } = this.gameState.determineTrickWinner();
                    if (winner === i) {
                        trickCardArea.classList.add('winner');
                    }
                }
            }
        }
    }
}

renderMobileUserTrick() {
    if (!document.body.classList.contains('mobile-mode')) return;
    const userTrickArea = document.getElementById('mobile-user-trick');
    const trickInfo = document.getElementById('mobile-trick-info');
    if (!userTrickArea || !trickInfo) return;

    userTrickArea.innerHTML = '';
    userTrickArea.classList.remove('winner');

    if (this.gameState.phase === PHASES.PLAYING ||
        this.gameState.phase === PHASES.TRICK_END) {
        const play = this.gameState.trick.cards.find(p => p.player === 0);
        if (play) {
            const cardEl = this.createCardElement(play.card, { faceUp: true });
            userTrickArea.appendChild(cardEl);

            if (this.gameState.trick.cards.length > 0) {
                const { winner } = this.gameState.determineTrickWinner();
                if (winner === 0) {
                    userTrickArea.classList.add('winner');
                }
            }
        }

        // 트릭 정보
        if (this.gameState.trick.cards.length > 0) {
            const leadSuit = this.gameState.trick.leadSuit;
            const points = this.gameState.trick.cards.reduce(
                (sum, p) => sum + (p.card.isPointCard() ? 1 : 0), 0
            );
            let info = `리드: ${SUIT_NAMES[leadSuit] || '조커'} | 점수: ${points}`;
            const { winner } = this.gameState.determineTrickWinner();
            if (winner !== null) {
                info += ` | ${this.gameState.players[winner].name}`;
            }
            if (this.gameState.trick.jokerCalled) info += ' | 🃏콜';
            trickInfo.textContent = info;
            trickInfo.style.display = '';
        } else {
            trickInfo.style.display = 'none';
        }
    } else {
        trickInfo.style.display = 'none';
    }
}



            renderAILog() {
                const logContent = document.getElementById('ai-log-content');
                const panel = document.getElementById('ai-log-panel');
                if (!this.settings.showAILog) { panel.classList.add('hidden'); return; }
                panel.classList.remove('hidden');
                logContent.innerHTML = '';
                const logs = this.gameState.aiLogs.slice(-10).reverse();
                for (const log of logs) {
                    const entry = document.createElement('div');
                    entry.className = 'log-entry';
                    const header = document.createElement('div');
                    header.className = 'log-header';
                    header.textContent = `[R${log.round}] ${log.playerName}: ${log.action}`;
                    entry.appendChild(header);
                    if (log.reasoning && log.reasoning.length > 0) {
                        const reasons = document.createElement('div');
                        reasons.className = 'log-reasons';
                        for (const reason of log.reasoning) {
                            const line = document.createElement('div');
                            line.className = 'reason-line'; line.textContent = `- ${reason}`;
                            reasons.appendChild(line);
                        }
                        entry.appendChild(reasons);
                    }
                    logContent.appendChild(entry);
                }
            }

            addAILog(playerIndex, action, reasoning = []) {
                const player = this.gameState.players[playerIndex];
                this.gameState.addAILog({ round: this.gameState.round, playerName: player.name, action, reasoning });
                this.renderAILog();
            }

            setActionButtons(buttons) {
                const container = document.getElementById('action-buttons');
                container.innerHTML = '';
                for (const btn of buttons) {
                    const el = document.createElement('button');
                    el.textContent = btn.text;
                    el.className = btn.primary ? 'primary' : 'secondary';
                    el.disabled = btn.disabled || false;
                    el.addEventListener('click', btn.onClick);
                    container.appendChild(el);
                }
            }

            clearActionButtons() {
                document.getElementById('action-buttons').innerHTML = '';
                document.getElementById('action-message').innerHTML = '';
            }

            setMessage(message) {
                document.getElementById('action-message').innerHTML = `<span>${message}</span>`;
            }

            clearMessage() { document.getElementById('action-message').innerHTML = ''; }

            // ===== 비딩 모달 =====
            showBiddingModal() {
                this.selectedBid = { value: null, suit: null };
                const currentBid = this.gameState.bidding.currentBid;
                document.getElementById('current-bid-display').textContent =
                    currentBid ? `${currentBid.value}${currentBid.suit === 'none' ? 'No' : SUIT_SYMBOLS[currentBid.suit]}` : '없음';
                
                // ★ 비딩 모달 내 손패 표시
                const oldPreview = document.getElementById('bid-hand-preview');
                if (oldPreview) oldPreview.remove();
                const handPreview = document.createElement('div');
                handPreview.id = 'bid-hand-preview';
                handPreview.style.cssText = 'display:flex;justify-content:center;flex-wrap:nowrap;gap:0;margin-bottom:12px;padding:8px;background:rgba(0,0,0,0.3);border-radius:6px;';

                const myPlayer = this.gameState.players[0];
                const mySortedHand = sortCards(myPlayer.hand, this.gameState.contract.giruda, this.gameState.contract.mighty);
                const isMobile = document.body.classList.contains('mobile-mode');
                const cardW = isMobile ? 43 : 86;
                const cardH = isMobile ? 58 : 116;
                const cardMargin = isMobile ? -20 : -40;

                for (const card of mySortedHand) {
                    const cardEl = this.createCardElement(card, { faceUp: true });
                    cardEl.style.cssText = `width:${cardW}px;height:${cardH}px;margin-left:${cardMargin}px;flex-shrink:0;`;
                    const img = cardEl.querySelector('img');
                    if (img) { img.style.width = '100%'; img.style.height = '100%'; }
                    handPreview.appendChild(cardEl);
                }
                if (handPreview.firstChild) handPreview.firstChild.style.marginLeft = '0';

                const currentBidDisplay = document.querySelector('#bidding-modal .current-bid');
                currentBidDisplay.parentNode.insertBefore(handPreview, currentBidDisplay);
                    
                const numbersContainer = document.getElementById('bid-numbers');
                numbersContainer.innerHTML = '';
                for (let i = GAME_CONFIG.MIN_BID; i <= GAME_CONFIG.MAX_BID; i++) {
                    const btn = document.createElement('button');
                    btn.textContent = i;
                    btn.addEventListener('click', () => this.selectBidNumber(i));
                    numbersContainer.appendChild(btn);
                }

                const suitsContainer = document.getElementById('bid-suits');
                suitsContainer.innerHTML = '';
                const suits = [
                    { suit: SUITS.SPADE, symbol: '♠', red: false },
                    { suit: SUITS.DIAMOND, symbol: '◆', red: true },
                    { suit: SUITS.HEART, symbol: '♥', red: true },
                    { suit: SUITS.CLUB, symbol: '♣', red: false },
                    { suit: 'none', symbol: 'No', red: false }
                ];
                for (const s of suits) {
                    const btn = document.createElement('button');
                    btn.textContent = s.symbol;
                    if (s.red) btn.classList.add('red');
                    btn.addEventListener('click', () => this.selectBidSuit(s.suit));
                    suitsContainer.appendChild(btn);
                }

                document.getElementById('bid-preview').textContent = '-';
                document.getElementById('bid-submit').disabled = true;
                document.getElementById('bid-submit').onclick = () => this.submitBid();
                document.getElementById('bid-pass').onclick = () => this.passBid();

                // ★ 퀵 비딩 버튼: 이전에 비딩한 수트로 +1
                const quickContainer = document.getElementById('bid-quick-buttons');
                if (quickContainer) quickContainer.remove();

                if (currentBid) {
                    // 내 마지막 비딩 찾기
                    const myLastBid = [...this.gameState.bidding.history]
                        .reverse()
                        .find(h => h.player === 0 && h.type === 'bid');

                    if (myLastBid) {
                        const quickDiv = document.createElement('div');
                        quickDiv.id = 'bid-quick-buttons';
                        quickDiv.style.cssText = 'display:flex;gap:8px;justify-content:center;margin-bottom:12px;';

                        // 같은 수트로 +1 버튼
                        const nextValue = currentBid.value + 1;
                        const mySuit = myLastBid.suit;
                        const mySuitSymbol = mySuit === 'none' ? 'No' : SUIT_SYMBOLS[mySuit];

                        if (nextValue <= GAME_CONFIG.MAX_BID && this.gameState.isValidBid(nextValue, mySuit)) {
                            const quickBtn = document.createElement('button');
                            quickBtn.textContent = `${nextValue}${mySuitSymbol} 바로 비딩`;
                            quickBtn.style.cssText = 'padding:8px 16px;font-size:14px;background:#FF9800;color:white;border:none;border-radius:5px;cursor:pointer;font-weight:bold;';
                            quickBtn.addEventListener('click', () => {
                                if (this.onBidSubmit) this.onBidSubmit(nextValue, mySuit);
                                this.hideBiddingModal();
                            });
                            quickBtn.addEventListener('mouseenter', () => { quickBtn.style.transform = 'scale(1.05)'; });
                            quickBtn.addEventListener('mouseleave', () => { quickBtn.style.transform = 'scale(1)'; });
                            quickDiv.appendChild(quickBtn);
                        }

                        // 같은 수트 같은 숫자로 이길 수 있는 경우 (수트 우위)
                        if (this.gameState.isValidBid(currentBid.value, mySuit)) {
                            const sameBtn = document.createElement('button');
                            sameBtn.textContent = `${currentBid.value}${mySuitSymbol} 바로 비딩`;
                            sameBtn.style.cssText = 'padding:8px 16px;font-size:14px;background:#2196F3;color:white;border:none;border-radius:5px;cursor:pointer;font-weight:bold;';
                            sameBtn.addEventListener('click', () => {
                                if (this.onBidSubmit) this.onBidSubmit(currentBid.value, mySuit);
                                this.hideBiddingModal();
                            });
                            sameBtn.addEventListener('mouseenter', () => { sameBtn.style.transform = 'scale(1.05)'; });
                            sameBtn.addEventListener('mouseleave', () => { sameBtn.style.transform = 'scale(1)'; });
                            quickDiv.appendChild(sameBtn);
                        }

                        if (quickDiv.children.length > 0) {
                            const bidActions = document.querySelector('.bid-actions');
                            bidActions.parentNode.insertBefore(quickDiv, bidActions);
                        }
                    }
                }

                document.getElementById('modal-overlay').classList.remove('hidden');
                document.getElementById('bidding-modal').classList.remove('hidden');
            }


            hideBiddingModal() {
                document.getElementById('modal-overlay').classList.add('hidden');
                document.getElementById('bidding-modal').classList.add('hidden');
            }

            selectBidNumber(value) {
                this.selectedBid.value = value;
                document.querySelectorAll('#bid-numbers button').forEach(btn => {
                    btn.classList.toggle('selected', parseInt(btn.textContent) === value);
                });
                this.updateBidPreview();
            }

            selectBidSuit(suit) {
                this.selectedBid.suit = suit;
                const symbols = { [SUITS.SPADE]: '♠', [SUITS.DIAMOND]: '◆', [SUITS.HEART]: '♥', [SUITS.CLUB]: '♣', 'none': 'No' };
                document.querySelectorAll('#bid-suits button').forEach(btn => {
                    btn.classList.toggle('selected', btn.textContent === symbols[suit]);
                });
                this.updateBidPreview();
            }

            updateBidPreview() {
                const { value, suit } = this.selectedBid;
                const preview = document.getElementById('bid-preview');
                const submitBtn = document.getElementById('bid-submit');
                if (value && suit) {
                    const symbol = suit === 'none' ? 'No' : SUIT_SYMBOLS[suit];
                    preview.textContent = `${value}${symbol}`;
                    const isValid = this.gameState.isValidBid(value, suit);
                    submitBtn.disabled = !isValid;
                    preview.style.color = isValid ? '#4CAF50' : '#f44336';
                } else {
                    preview.textContent = '-'; submitBtn.disabled = true;
                }
            }

            submitBid() {
                if (this.onBidSubmit) this.onBidSubmit(this.selectedBid.value, this.selectedBid.suit);
                this.hideBiddingModal();
            }

            passBid() {
                if (this.onBidPass) this.onBidPass();
                this.hideBiddingModal();
            }

            // ===== 친구 선언 모달 =====
            showFriendModal() {
                this.selectedFriend = { suit: null, rank: null };
                const mighty = this.gameState.contract.mighty;
                const giruda = this.gameState.contract.giruda;
                const masterIndex = this.gameState.contract.master;
                const masterHand = this.gameState.players[masterIndex].hand;
                const hasMighty = masterHand.some(c => c.equals(mighty));
                const hasJoker = masterHand.some(c => c.isJoker);

                // ★★★ 퀵 선택 버튼 동적 생성 ★★★
                const quickContainer = document.querySelector('.quick-friend-selection');
                quickContainer.innerHTML = '';

                // 마이티 버튼: 주공이 마이티를 안 가지고 있을 때만
                if (!hasMighty) {
                    const mightyBtn = document.createElement('button');
                    mightyBtn.className = 'quick-friend-btn mighty-btn';
                    mightyBtn.innerHTML = `
                <span class="btn-icon">👑</span>
                <span class="btn-text">마이티 친구</span>
                <span class="btn-card${mighty.isRed() ? ' red' : ''}">${mighty.toString()}</span>
            `;
                    mightyBtn.onclick = () => {
                        if (this.onFriendDeclare) this.onFriendDeclare(mighty);
                        this.hideFriendModal();
                    };
                    quickContainer.appendChild(mightyBtn);
                }

                // 조커 버튼: 주공이 조커를 안 가지고 있을 때만
                if (!hasJoker) {
                    const jokerBtn = document.createElement('button');
                    jokerBtn.className = 'quick-friend-btn joker-btn';
                    jokerBtn.innerHTML = `
                <span class="btn-icon">🃏</span>
                <span class="btn-text">조커 친구</span>
                <span class="btn-card">JOKER</span>
            `;
                    jokerBtn.onclick = () => {
                        if (this.onFriendDeclare) this.onFriendDeclare(Card.createJoker());
                        this.hideFriendModal();
                    };
                    quickContainer.appendChild(jokerBtn);
                }

                // 기루다 A 버튼: 기루다가 있고, 기루다A가 마이티가 아니고, 주공이 안 가지고 있을 때
                if (giruda) {
                    const girudaAce = new Card(giruda, 'A');
                    if (!girudaAce.equals(mighty) && !masterHand.some(c => c.equals(girudaAce))) {
                        const aceBtn = document.createElement('button');
                        aceBtn.className = 'quick-friend-btn';
                        aceBtn.style.cssText = 'background: linear-gradient(135deg, #1565C0 0%, #42A5F5 100%); color: white; border-color: #1565C0;';
                        aceBtn.innerHTML = `
                    <span class="btn-icon">🂡</span>
                    <span class="btn-text">기루다 A 친구</span>
                    <span class="btn-card${girudaAce.isRed() ? ' red' : ''}">${girudaAce.toString()}</span>
                `;
                        aceBtn.onclick = () => {
                            if (this.onFriendDeclare) this.onFriendDeclare(girudaAce);
                            this.hideFriendModal();
                        };
                        quickContainer.appendChild(aceBtn);
                    }

                    // 기루다 K 버튼: 주공이 안 가지고 있을 때
                    const girudaKing = new Card(giruda, 'K');
                    if (!masterHand.some(c => c.equals(girudaKing))) {
                        const kingBtn = document.createElement('button');
                        kingBtn.className = 'quick-friend-btn';
                        kingBtn.style.cssText = 'background: linear-gradient(135deg, #4527A0 0%, #7E57C2 100%); color: white; border-color: #4527A0;';
                        kingBtn.innerHTML = `
                    <span class="btn-icon">♚</span>
                    <span class="btn-text">기루다 K 친구</span>
                    <span class="btn-card${girudaKing.isRed() ? ' red' : ''}">${girudaKing.toString()}</span>
                `;
                        kingBtn.onclick = () => {
                            if (this.onFriendDeclare) this.onFriendDeclare(girudaKing);
                            this.hideFriendModal();
                        };
                        quickContainer.appendChild(kingBtn);
                    }
                }

                // 퀵 버튼이 하나도 없으면 안내 메시지
                if (quickContainer.children.length === 0) {
                    const notice = document.createElement('div');
                    notice.style.cssText = 'color: #aaa; text-align: center; padding: 10px; font-size: 14px;';
                    notice.textContent = '주요 카드를 모두 보유 중 - 아래에서 직접 선택하거나 노프렌드를 선언하세요';
                    quickContainer.appendChild(notice);
                }

                const suitsContainer = document.getElementById('friend-suit-buttons');

                suitsContainer.innerHTML = '';
                const suits = [
                    { suit: SUITS.SPADE, symbol: '♠', red: false },
                    { suit: SUITS.DIAMOND, symbol: '◆', red: true },
                    { suit: SUITS.HEART, symbol: '♥', red: true },
                    { suit: SUITS.CLUB, symbol: '♣', red: false }
                ];
                for (const s of suits) {
                    const btn = document.createElement('button');
                    btn.textContent = s.symbol;
                    btn.style.cssText = `font-size:24px;width:50px;height:50px;padding:0;border:2px solid #444;background:#333;color:${s.red ? '#d32f2f' : 'white'};border-radius:5px;cursor:pointer;`;
                    btn.addEventListener('click', () => this.selectFriendSuit(s.suit));
                    suitsContainer.appendChild(btn);
                }

                const ranksContainer = document.getElementById('friend-rank-buttons');
                ranksContainer.innerHTML = '';
                for (const rank of RANKS) {
                    const btn = document.createElement('button');
                    btn.textContent = rank;
                    btn.addEventListener('click', () => this.selectFriendRank(rank));
                    ranksContainer.appendChild(btn);
                }

                document.getElementById('friend-preview').textContent = '-';
                document.getElementById('friend-confirm').onclick = () => this.confirmFriend();
                document.getElementById('no-friend').onclick = () => this.declareNoFriend();
                document.getElementById('modal-overlay').classList.remove('hidden');
                document.getElementById('friend-modal').classList.remove('hidden');
            }

            hideFriendModal() {
                document.getElementById('modal-overlay').classList.add('hidden');
                document.getElementById('friend-modal').classList.add('hidden');
            }

            selectFriendSuit(suit) {
                this.selectedFriend.suit = suit;
                const symbols = { [SUITS.SPADE]: '♠', [SUITS.DIAMOND]: '◆', [SUITS.HEART]: '♥', [SUITS.CLUB]: '♣' };
                document.querySelectorAll('#friend-suit-buttons button').forEach(btn => {
                    const isSel = btn.textContent === symbols[suit];
                    btn.style.background = isSel ? '#4CAF50' : '#333';
                    btn.style.borderColor = isSel ? '#4CAF50' : '#444';
                });
                this.updateFriendPreview();
            }

            selectFriendRank(rank) {
                this.selectedFriend.rank = rank;
                document.querySelectorAll('#friend-rank-buttons button').forEach(btn => {
                    btn.classList.toggle('selected', btn.textContent === rank);
                });
                this.updateFriendPreview();
            }

            updateFriendPreview() {
                const { suit, rank } = this.selectedFriend;
                const preview = document.getElementById('friend-preview');
                if (rank === 'JOKER') preview.textContent = 'JOKER';
                else if (suit && rank) preview.textContent = `${SUIT_SYMBOLS[suit]}${rank}`;
                else preview.textContent = '-';
            }

            confirmFriend() {
                const { suit, rank } = this.selectedFriend;
                let card = null;
                if (rank === 'JOKER') card = Card.createJoker();
                else if (suit && rank) card = new Card(suit, rank);
                if (card && this.onFriendDeclare) this.onFriendDeclare(card);
                this.hideFriendModal();
            }

            declareNoFriend() {
                if (this.onFriendDeclare) this.onFriendDeclare(null);
                this.hideFriendModal();
            }

            // ===== 카드 교환 모달 =====
            showExchangeModal() {
                this.selectedCards = [];
                this.newGiruda = null;
                this.isNoGiruda = false;
                this.isSolino = false;

                const masterIndex = this.gameState.contract.master;
                const player = this.gameState.players[masterIndex];
                const handContainer = document.getElementById('exchange-hand');
                handContainer.innerHTML = '';

                // ★ 바닥에서 가져온 3장 식별
                const floorCards = this.gameState.floorCards;
                const originalCards = player.hand.filter(
                    c => !floorCards.some(fc => fc.equals(c))
                );
                const floorCardsInHand = player.hand.filter(
                    c => floorCards.some(fc => fc.equals(c))
                );

                const sortedOriginal = sortCards(originalCards, this.gameState.contract.giruda, this.gameState.contract.mighty);
                const sortedFloor = sortCards(floorCardsInHand, this.gameState.contract.giruda, this.gameState.contract.mighty);

                // ★ 기존 패 라벨 + 카드
                const origLabel = document.createElement('div');
                origLabel.className = 'exchange-section-label';
                origLabel.textContent = `기존 패 (${sortedOriginal.length}장)`;
                handContainer.appendChild(origLabel);

                const origGroup = document.createElement('div');
                origGroup.className = 'exchange-hand-group';
                for (const card of sortedOriginal) {
                    const cardEl = this.createCardElement(card, { faceUp: true, isSpecial: this.isSpecialCard(card) });
                    cardEl.style.cursor = 'pointer';
                    cardEl.addEventListener('click', () => this.toggleExchangeCard(card, cardEl));
                    origGroup.appendChild(cardEl);
                }
                handContainer.appendChild(origGroup);

                // ★ 바닥 패 라벨 + 카드
                const floorLabel = document.createElement('div');
                floorLabel.className = 'exchange-section-label floor-label';
                floorLabel.textContent = `바닥에서 가져온 카드 (${sortedFloor.length}장)`;
                handContainer.appendChild(floorLabel);

                const floorGroup = document.createElement('div');
                floorGroup.className = 'exchange-hand-group';
                for (const card of sortedFloor) {
                    const cardEl = this.createCardElement(card, { faceUp: true, isSpecial: this.isSpecialCard(card) });
                    cardEl.style.cursor = 'pointer';
                    cardEl.addEventListener('click', () => this.toggleExchangeCard(card, cardEl));
                    floorGroup.appendChild(cardEl);
                }
                handContainer.appendChild(floorGroup);

                document.getElementById('exchange-count').textContent = '0';
                document.getElementById('exchange-confirm').disabled = true;
                document.getElementById('exchange-confirm').onclick = () => this.confirmExchange();
                this.setupGirudaChangeUI();

                const masterEl = document.getElementById(`player-${masterIndex}`);
                if (masterEl) masterEl.querySelector('.player-hand').style.visibility = 'hidden';

                document.getElementById('modal-overlay').classList.remove('hidden');
                document.getElementById('exchange-modal').classList.remove('hidden');
            }


            setupGirudaChangeUI() {
                const currentGiruda = this.gameState.contract.giruda;
                const currentBid = this.gameState.contract.bidValue;
                const isMaxBid = currentBid >= GAME_CONFIG.MAX_BID;

                this.newGiruda = null;
                this.isNoGiruda = false;
                this.isSolino = false;

                const currentGirudaName = currentGiruda ? SUIT_NAMES[currentGiruda] : '노기루다';
                const currentGirudaSymbol = currentGiruda ? SUIT_SYMBOLS[currentGiruda] : '없음';

                document.getElementById('giruda-current-info').innerHTML =
                    `현재: <span class="current-giruda">${currentGirudaSymbol} ${currentGirudaName}</span> / 공약: <span class="current-bid">${currentBid}</span>`;

                if (isMaxBid) {
                    document.getElementById('giruda-change-cost').innerHTML =
                        '<span style="color: #4CAF50;">★ 공약 20 특전: 무료 변경 / 노기루다 / 노프렌드 가능</span>';
                } else {
                    const newBid = Math.min(currentBid + 2, GAME_CONFIG.MAX_BID);
                    document.getElementById('giruda-change-cost').textContent = `변경 시 공약 +2 → ${newBid}`;
                }

                const buttonsContainer = document.getElementById('giruda-change-buttons');
                if (!buttonsContainer) return;
                buttonsContainer.innerHTML = '';

                const suits = [
                    { suit: SUITS.SPADE, symbol: '♠', isRed: false },
                    { suit: SUITS.DIAMOND, symbol: '◆', isRed: true },
                    { suit: SUITS.HEART, symbol: '♥', isRed: true },
                    { suit: SUITS.CLUB, symbol: '♣', isRed: false }
                ];

                for (const { suit, symbol, isRed } of suits) {
                    const btn = document.createElement('button');
                    btn.className = `giruda-btn ${isRed ? 'red' : 'black'}`;
                    btn.textContent = symbol;
                    if (suit === currentGiruda && !isMaxBid) {
                        btn.classList.add('current'); btn.disabled = true;
                    } else {
                        if (suit === currentGiruda) btn.classList.add('current');
                        btn.addEventListener('click', () => this.selectNewGiruda(suit, btn));
                    }
                    buttonsContainer.appendChild(btn);
                }

                if (isMaxBid) {
                    const noGirudaBtn = document.createElement('button');
                    noGirudaBtn.className = 'giruda-btn no-giruda';
                    noGirudaBtn.textContent = 'No';
                    noGirudaBtn.addEventListener('click', () => this.selectNoGiruda(noGirudaBtn));
                    buttonsContainer.appendChild(noGirudaBtn);

                    const separator = document.createElement('span');
                    separator.className = 'giruda-separator'; separator.textContent = '|';
                    buttonsContainer.appendChild(separator);

                    const solinoLabel = document.createElement('label');
                    solinoLabel.className = 'solino-option';
                    solinoLabel.innerHTML = `<input type="checkbox" id="solino-check"><span>노프렌드 (솔리노)</span>`;
                    buttonsContainer.appendChild(solinoLabel);

                    setTimeout(() => {
                        const cb = document.getElementById('solino-check');
                        if (cb) cb.addEventListener('change', (e) => { this.isSolino = e.target.checked; this.updateExchangeConfirmButton(); });
                    }, 0);
                }
            }

            selectNoGiruda(btnEl) {
                document.querySelectorAll('#giruda-change-buttons .giruda-btn').forEach(btn => btn.classList.remove('selected'));
                if (this.isNoGiruda) { this.isNoGiruda = false; this.newGiruda = null; }
                else { this.isNoGiruda = true; this.newGiruda = null; btnEl.classList.add('selected'); }
                this.updateExchangeConfirmButton();
            }

            selectNewGiruda(suit, btnEl) {
                document.querySelectorAll('#giruda-change-buttons .giruda-btn').forEach(btn => btn.classList.remove('selected'));
                this.isNoGiruda = false;
                if (this.newGiruda === suit) { this.newGiruda = null; this.updateExchangeConfirmButton(); return; }
                this.newGiruda = suit; btnEl.classList.add('selected');
                this.updateExchangeConfirmButton();
            }

            updateExchangeConfirmButton() {
                const btn = document.getElementById('exchange-confirm');
                btn.disabled = this.selectedCards.length !== 3;
                const currentBid = this.gameState.contract.bidValue;
                const isMaxBid = currentBid >= GAME_CONFIG.MAX_BID;
                let changes = [];
                if (this.isNoGiruda) changes.push('노기루다');
                else if (this.newGiruda && this.newGiruda !== this.gameState.contract.giruda) {
                    if (isMaxBid) changes.push(`기루다 → ${SUIT_SYMBOLS[this.newGiruda]}`);
                    else changes.push(`기루다 → ${SUIT_SYMBOLS[this.newGiruda]} (공약 ${Math.min(currentBid + 2, GAME_CONFIG.MAX_BID)})`);
                }
                if (this.isSolino) changes.push('노프렌드');
                btn.textContent = changes.length > 0 ? `확인 (${changes.join(', ')})` : '확인';
            }

            hideExchangeModal() {
                document.getElementById('modal-overlay').classList.add('hidden');
                document.getElementById('exchange-modal').classList.add('hidden');
                const masterIndex = this.gameState.contract.master;
                if (masterIndex !== null && masterIndex !== undefined) {
                    const masterEl = document.getElementById(`player-${masterIndex}`);
                    if (masterEl) masterEl.querySelector('.player-hand').style.visibility = '';
                }
            }


            toggleExchangeCard(card, cardEl) {
                const index = this.selectedCards.findIndex(c => c.equals(card));
                if (index >= 0) { this.selectedCards.splice(index, 1); cardEl.classList.remove('selected'); }
                else if (this.selectedCards.length < 3) { this.selectedCards.push(card); cardEl.classList.add('selected'); }
                document.getElementById('exchange-count').textContent = this.selectedCards.length;
                this.updateExchangeConfirmButton();
            }

            confirmExchange() {
                if (this.selectedCards.length === 3 && this.onExchangeConfirm) {
                    this.onExchangeConfirm(this.selectedCards, { newGiruda: this.newGiruda, isNoGiruda: this.isNoGiruda, isSolino: this.isSolino });
                }
                this.hideExchangeModal();
            }

            // ===== 조커 수트 모달 =====
            showJokerCallModal() {
                const container = document.getElementById('joker-suit-buttons');
                container.innerHTML = '';
                const suits = [
                    { suit: SUITS.SPADE, symbol: '♠', red: false },
                    { suit: SUITS.DIAMOND, symbol: '◆', red: true },
                    { suit: SUITS.HEART, symbol: '♥', red: true },
                    { suit: SUITS.CLUB, symbol: '♣', red: false }
                ];
                for (const s of suits) {
                    const btn = document.createElement('button');
                    btn.textContent = s.symbol;
                    if (s.red) btn.classList.add('red');
                    btn.addEventListener('click', () => {
                        if (this.onJokerSuitSelect) this.onJokerSuitSelect(s.suit);
                        this.hideJokerCallModal();
                    });
                    container.appendChild(btn);
                }
                document.getElementById('modal-overlay').classList.remove('hidden');
                document.getElementById('joker-call-modal').classList.remove('hidden');
            }

            hideJokerCallModal() {
                document.getElementById('modal-overlay').classList.add('hidden');
                document.getElementById('joker-call-modal').classList.add('hidden');
            }

            // ===== 결과 모달 =====
        showResultModal(result, gameHistory = []) {
        const title = document.getElementById('result-title');
        const content = document.getElementById('result-content');
        const userResult = result.results.find(r => r.player === 0);
        const userWon = userResult && userResult.change > 0;

        title.textContent = userWon ? '🎉 승리!' : '😢 패배';
        title.className = userWon ? 'win' : 'lose';

        const govScore = this.gameState.governmentScore;
        const bidValue = this.gameState.contract.bidValue;
        const winnerText = result.winner === 'government' ? '여당 승리' : '야당 승리';
        const backrunText = result.isBackrun ? ' (백런!)' : '';

        let html = `<div class="result-summary">${winnerText}${backrunText} — 여당 ${govScore}/${bidValue}</div>`;

        // 점수표
        html += '<div class="result-scores">';
        html += '<div class="result-header"><span>플레이어</span><span>획득</span><span>변동</span></div>';
        for (const r of result.results) {
            const player = this.gameState.players[r.player];
            const earnedPoints = player.getScore();
            const changeClass = r.change >= 0 ? 'positive' : 'negative';
            const changeText = r.change >= 0 ? `+${r.change}` : `${r.change}`;
            const roleIcon = player.role === ROLES.MASTER ? '★' : (player.role === ROLES.FRIEND ? '◆' : '');
            html += `<div class="score-row">
                <span class="player-name">${roleIcon}${player.name}</span>
                <span class="earned-points">${earnedPoints}</span>
                <span class="score-change ${changeClass}">${changeText}</span>
            </div>`;
        }
        html += '</div>';

        // 친구 공헌 (한 줄로 축약)
        const contract = this.gameState.contract;
        const fc = this.gameState.friendContribution;
        if (!contract.isNoFriend && !contract.isSolino && contract.friend !== null && fc.tricksWon > 0) {
            const fn = this.gameState.players[contract.friend]?.name || '친구';
            const sp = [fc.mightyUsed && '마이티', fc.jokerUsed && '조커'].filter(Boolean).join(',');
            html += `<div class="friend-contribution-line">🤝 ${fn}: ${fc.tricksWon}트릭 ${fc.pointsSecured}점${sp ? ' | ' + sp : ''}</div>`;
        }

        // 게임 기록 (최근 5게임만)
        if (gameHistory && gameHistory.length > 0) {
            const recent = gameHistory.slice(-5);
            html += '<div class="game-history"><div class="history-header">📊 기록</div>';
            html += '<div class="history-table-wrapper"><table class="history-table">';
            html += '<thead><tr><th>#</th><th>공약</th><th></th>';
            for (let i = 0; i < 5; i++) html += `<th>${i === 0 ? '나' : 'A' + i}</th>`;
            html += '</tr></thead><tbody>';
            for (const g of recent) {
                const gs = g.giruda ? SUIT_SYMBOLS[g.giruda] : 'N';
                const wc = g.winner === 'government' ? 'gov-win' : 'opp-win';
                const wt = g.winner === 'government' ? '여' : '야';
                html += `<tr><td>${g.gameNumber}</td><td>${g.bidValue}${gs}</td><td class="${wc}">${wt}</td>`;
                for (let i = 0; i < 5; i++) {
                    const c = g.results.find(r => r.player === i)?.change || 0;
                    const cl = c >= 0 ? 'positive' : 'negative';
                    const t = c >= 0 ? '+' + c : '' + c;
                    const rl = g.master === i ? '★' : (g.friend === i ? '☆' : '');
                    html += `<td class="${cl}">${rl}${t}</td>`;
                }
                html += '</tr>';
            }
            html += '</tbody><tfoot><tr><td colspan="3"><b>합계</b></td>';
            const last = gameHistory[gameHistory.length - 1];
            for (let i = 0; i < 5; i++) {
                const tot = last.cumulativeScores[i];
                const cl = tot >= 0 ? 'positive' : 'negative';
                html += `<td class="${cl}"><b>${tot >= 0 ? '+' + tot : tot}</b></td>`;
            }
            html += '</tr></tfoot></table></div></div>';
        }

        content.innerHTML = html;
        document.getElementById('result-modal').classList.remove('hidden');
    }

    hideResultModal() {
        document.getElementById('result-modal').classList.add('hidden');
    }



            showSettingsModal() {
                document.getElementById('setting-show-ai-cards').checked = this.settings.showAICards;
                document.getElementById('setting-show-ai-log').checked = this.settings.showAILog;
                document.getElementById('setting-highlight-playable').checked = this.settings.highlightPlayable;
                document.getElementById('setting-ai-speed').value = this.settings.aiSpeed;
                document.getElementById('setting-use-sayeon').checked = this.settings.useSayeon;
                document.getElementById('modal-overlay').classList.remove('hidden');
                document.getElementById('settings-modal').classList.remove('hidden');
            }

            hideSettingsModal() {
                document.getElementById('modal-overlay').classList.add('hidden');
                document.getElementById('settings-modal').classList.add('hidden');
            }

            onCardClick(card) { if (this.onCardSelect) this.onCardSelect(card); }

            setCallbacks(callbacks) {
                this.onBidSubmit = callbacks.onBidSubmit;
                this.onBidPass = callbacks.onBidPass;
                this.onFriendDeclare = callbacks.onFriendDeclare;
                this.onExchangeConfirm = callbacks.onExchangeConfirm;
                this.onCardSelect = callbacks.onCardSelect;
                this.onJokerSuitSelect = callbacks.onJokerSuitSelect;
                this.onNewGame = callbacks.onNewGame;
                this.onEndGame = callbacks.onEndGame;
            }
        }

        // ========================================
        // ===== SoundManager (신규) =====
        // ========================================

        class SoundManager {
            constructor() {
                this.context = null;
                this.masterVolume = 0.5;
                this.enabled = true;
                this.initialized = false;
            }

            init() {
                if (this.initialized) return;
                try {
                    this.context = new (window.AudioContext || window.webkitAudioContext)();
                    this.initialized = true;
                } catch (e) {
                    console.warn('Web Audio API not supported');
                    this.enabled = false;
                }
            }

            async playTone(freq, type, duration, vol = 1) {
                if (!this.enabled || !this.context) return;
                if (this.context.state === 'suspended') await this.context.resume();

                const osc = this.context.createOscillator();
                const gain = this.context.createGain();

                osc.type = type;
                osc.frequency.setValueAtTime(freq, this.context.currentTime);

                gain.gain.setValueAtTime(vol * this.masterVolume, this.context.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, this.context.currentTime + duration);

                osc.connect(gain);
                gain.connect(this.context.destination);

                osc.start();
                osc.stop(this.context.currentTime + duration);
            }

            playCardFlip() { this.playTone(600, 'sine', 0.1, 0.3); }
            playCardPlay() { this.playTone(400, 'triangle', 0.15, 0.5); }
            playError() { this.playTone(150, 'sawtooth', 0.2, 0.5); }
            playTurnStart() { this.playTone(800, 'sine', 0.3, 0.2); }
            playWin() {
                if (!this.enabled) return;
                this.playTone(523.25, 'sine', 0.2, 0.4); // C5
                setTimeout(() => this.playTone(659.25, 'sine', 0.2, 0.4), 150); // E5
                setTimeout(() => this.playTone(783.99, 'sine', 0.4, 0.4), 300); // G5
            }
            playMightySound() {
    if (!this.enabled) return;
    // 묵직한 임팩트 + 금관 느낌
    this.playTone(200, 'sine', 0.15, 0.6);
    setTimeout(() => this.playTone(400, 'triangle', 0.2, 0.5), 100);
    setTimeout(() => this.playTone(600, 'sine', 0.3, 0.4), 200);
    setTimeout(() => this.playTone(800, 'sine', 0.4, 0.3), 350);
}

playJokerSound() {
    if (!this.enabled) return;
    // 미스터리한 상승음
    this.playTone(300, 'sine', 0.2, 0.4);
    setTimeout(() => this.playTone(450, 'triangle', 0.2, 0.4), 120);
    setTimeout(() => this.playTone(600, 'sine', 0.3, 0.3), 240);
    setTimeout(() => this.playTone(900, 'sine', 0.15, 0.2), 360);
}

playCutSound() {
    if (!this.enabled) return;
    // 칼로 베는 느낌 - 하강 후 상승
    this.playTone(800, 'sawtooth', 0.08, 0.4);
    setTimeout(() => this.playTone(400, 'triangle', 0.15, 0.5), 80);
    setTimeout(() => this.playTone(600, 'sine', 0.2, 0.3), 200);
}

playOverCutSound() {
    if (!this.enabled) return;
    // 더 강한 컷 - 에스컬레이션
    this.playTone(600, 'sawtooth', 0.08, 0.5);
    setTimeout(() => this.playTone(300, 'triangle', 0.1, 0.5), 60);
    setTimeout(() => this.playTone(500, 'sawtooth', 0.08, 0.5), 150);
    setTimeout(() => this.playTone(800, 'sine', 0.3, 0.4), 250);
    setTimeout(() => this.playTone(1000, 'sine', 0.2, 0.3), 400);
}

playClashSound() {
    if (!this.enabled) return;
    // 충돌음 - 마이티 vs 조커
    this.playTone(150, 'sawtooth', 0.15, 0.6);
    this.playTone(200, 'square', 0.1, 0.4);
    setTimeout(() => {
        this.playTone(523, 'sine', 0.2, 0.5);
        this.playTone(659, 'sine', 0.2, 0.4);
    }, 200);
    setTimeout(() => this.playTone(784, 'sine', 0.4, 0.3), 400);
}

playJokerCallSound() {
    if (!this.enabled) return;
    // 호출음 - 뿔피리 느낌
    this.playTone(587, 'square', 0.15, 0.3);
    setTimeout(() => this.playTone(784, 'square', 0.15, 0.3), 150);
    setTimeout(() => this.playTone(587, 'square', 0.15, 0.3), 300);
    setTimeout(() => this.playTone(784, 'square', 0.3, 0.3), 450);
}

playFriendRevealSound() {
    if (!this.enabled) return;
    // 부드러운 벨
    this.playTone(523, 'sine', 0.3, 0.3);
    setTimeout(() => this.playTone(659, 'sine', 0.3, 0.3), 150);
    setTimeout(() => this.playTone(784, 'sine', 0.5, 0.2), 300);
}

playBackrunSound() {
    if (!this.enabled) return;
    // 충격적인 하강음
    this.playTone(800, 'sawtooth', 0.3, 0.6);
    setTimeout(() => this.playTone(400, 'sawtooth', 0.3, 0.6), 200);
    setTimeout(() => this.playTone(200, 'sawtooth', 0.3, 0.6), 400);
    setTimeout(() => this.playTone(100, 'square', 0.5, 0.5), 600);
}

playCoinSound() {
    if (!this.enabled) return;
    // 동전 소리
    this.playTone(1200, 'sine', 0.1, 0.3);
    setTimeout(() => this.playTone(1500, 'sine', 0.1, 0.3), 80);
    setTimeout(() => this.playTone(1800, 'sine', 0.15, 0.2), 160);
}

        }

        const soundManager = new SoundManager();

        class EffectManager {
    constructor() {
        this.setupStyles();
        this.listenEvents();
    }

    setupStyles() {
        const style = document.createElement('style');
        style.textContent = `
            /* 화면 흔들림 */
            @keyframes screenShake {
                0%, 100% { transform: translate(0, 0); }
                10% { transform: translate(-4px, 2px); }
                20% { transform: translate(4px, -2px); }
                30% { transform: translate(-2px, 4px); }
                40% { transform: translate(2px, -4px); }
                50% { transform: translate(-4px, 0); }
                60% { transform: translate(4px, 2px); }
                70% { transform: translate(-2px, -2px); }
                80% { transform: translate(2px, 4px); }
                90% { transform: translate(0, -2px); }
            }
            body.shake { animation: screenShake 0.4s ease; }

            /* 중앙 텍스트 팝업 */
            .event-popup {
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%) scale(0.3);
                font-size: 32px;
                font-weight: bold;
                z-index: 5000;
                pointer-events: none;
                opacity: 0;
                text-shadow: 0 0 20px currentColor, 0 2px 4px rgba(0,0,0,0.5);
                white-space: nowrap;
                animation: popupAppear 1.2s ease forwards;
            }

            @keyframes popupAppear {
                0%   { opacity: 0; transform: translate(-50%, -50%) scale(0.3); }
                15%  { opacity: 1; transform: translate(-50%, -50%) scale(1.2); }
                30%  { transform: translate(-50%, -50%) scale(1.0); }
                70%  { opacity: 1; transform: translate(-50%, -50%) scale(1.0); }
                100% { opacity: 0; transform: translate(-50%, -60%) scale(0.8); }
            }

            /* 카드 임팩트 줌 */
            @keyframes impactZoom {
                0%   { transform: scale(1); }
                20%  { transform: scale(1.5); }
                40%  { transform: scale(1.0); }
                60%  { transform: scale(1.2); }
                100% { transform: scale(1.0); }
            }

            .trick-card.impact .card {
                animation: impactZoom 0.5s ease !important;
                z-index: 100;
            }

            /* 광채 효과 */
            .trick-card.glow-gold .card {
                box-shadow: 0 0 30px rgba(255, 215, 0, 1), 0 0 60px rgba(255, 215, 0, 0.5) !important;
            }
            .trick-card.glow-purple .card {
                box-shadow: 0 0 30px rgba(156, 39, 176, 1), 0 0 60px rgba(156, 39, 176, 0.5) !important;
            }
            .trick-card.glow-red .card {
                box-shadow: 0 0 30px rgba(244, 67, 54, 1), 0 0 60px rgba(244, 67, 54, 0.5) !important;
            }
            .trick-card.glow-pink .card {
                box-shadow: 0 0 30px rgba(255, 105, 180, 1), 0 0 60px rgba(255, 105, 180, 0.5) !important;
            }
            .trick-card.glow-blue .card {
                box-shadow: 0 0 30px rgba(33, 150, 243, 1), 0 0 60px rgba(33, 150, 243, 0.5) !important;
            }

            /* 깨지는 효과 (이전 승자) */
            @keyframes cardCrack {
                0%   { opacity: 1; filter: brightness(1); }
                30%  { filter: brightness(2); }
                60%  { opacity: 0.6; filter: brightness(0.5) grayscale(0.8); }
                100% { opacity: 0.4; filter: brightness(0.3) grayscale(1); }
            }
            .trick-card.cracked .card {
                animation: cardCrack 0.6s ease forwards !important;
            }

            /* 파티클 컨테이너 */
            .particle-container {
                position: fixed;
                top: 0; left: 0;
                width: 100%; height: 100%;
                pointer-events: none;
                z-index: 4999;
                overflow: hidden;
            }

            .particle {
                position: absolute;
                font-size: 20px;
                animation: particleFly 1.5s ease-out forwards;
                pointer-events: none;
            }

            @keyframes particleFly {
                0%   { opacity: 1; transform: translate(0, 0) scale(1) rotate(0deg); }
                100% { opacity: 0; transform: translate(var(--px), var(--py)) scale(0.3) rotate(var(--pr)); }
            }

            /* 모바일 셀 광채 */
            .mobile-ai-cell.glow-gold { box-shadow: 0 0 20px rgba(255, 215, 0, 0.8) !important; }
            .mobile-ai-cell.glow-purple { box-shadow: 0 0 20px rgba(156, 39, 176, 0.8) !important; }
            .mobile-ai-cell.glow-red { box-shadow: 0 0 20px rgba(244, 67, 54, 0.8) !important; }
            .mobile-ai-cell.glow-pink { box-shadow: 0 0 20px rgba(255, 105, 180, 0.8) !important; }

            /* 모바일 트릭카드 임팩트 */
            .mobile-ai-cell .cell-trick-card.impact .card,
            #mobile-user-trick.impact .card {
                animation: impactZoom 0.5s ease !important;
            }
        `;
        document.head.appendChild(style);
    }

    listenEvents() {
        eventBus.on('mighty-played', (data) => this.onMightyPlayed(data));
        eventBus.on('joker-played', (data) => this.onJokerPlayed(data));
        eventBus.on('joker-called', (data) => this.onJokerCalled(data));
        eventBus.on('friend-revealed', (data) => this.onFriendRevealed(data));
        eventBus.on('giruda-cut', (data) => this.onGirudaCut(data));
        eventBus.on('over-cut', (data) => this.onOverCut(data));
        eventBus.on('mighty-beats-joker', (data) => this.onMightyBeatsJoker(data));
        eventBus.on('backrun', (data) => this.onBackrun(data));
        eventBus.on('contract-achieved', (data) => this.onContractAchieved(data));
        eventBus.on('big-score-trick', (data) => this.onBigScoreTrick(data));
    }

    // ===== Tier 1 이벤트 =====

    onMightyPlayed(data) {
        this.shakeScreen();
        this.showPopup('👑 마이티!', '#FFD700');
        this.addGlow(data.player, 'gold');
        this.addImpact(data.player);
        this.spawnParticles(data.player, ['✨', '⭐', '💫', '👑'], 12);
        soundManager.playMightySound();
    }

    onJokerPlayed(data) {
        this.showPopup('🃏 조커!', '#9C27B0');
        this.addGlow(data.player, 'purple');
        this.addImpact(data.player);
        this.spawnParticles(data.player, ['🃏', '✨', '💜', '🔮'], 10);
        soundManager.playJokerSound();
    }

    onMightyBeatsJoker(data) {
        this.shakeScreen();
        this.showPopup('💥 마이티 > 조커!', '#FF5722');
        this.addGlow(data.player, 'gold');
        this.addImpact(data.player);
        this.spawnParticles(data.player, ['💥', '⚡', '👑', '🔥'], 15);
        soundManager.playClashSound();
    }

    // ===== Tier 2 이벤트 =====

    onGirudaCut(data) {
        this.showPopup('⚔️ 기루다 컷!', '#f44336');
        this.addGlow(data.player, 'red');
        this.addImpact(data.player);
        this.addCrack(data.prevWinner);
        this.spawnParticles(data.player, ['⚔️', '🔥', '💢'], 8);
        soundManager.playCutSound();
    }

    onOverCut(data) {
        this.shakeScreen();
        this.showPopup('🔥 오버컷!', '#FF5722');
        this.addGlow(data.player, 'red');
        this.addImpact(data.player);
        this.addCrack(data.prevWinner);
        this.spawnParticles(data.player, ['🔥', '⚡', '💥', '🗡️'], 12);
        soundManager.playOverCutSound();
    }

    onJokerCalled(data) {
        this.showPopup('📢 조커콜!', '#2196F3');
        this.addGlow(data.player, 'blue');
        soundManager.playJokerCallSound();
    }

    onFriendRevealed(data) {
        this.showPopup('💕 친구 등장!', '#FF69B4');
        this.addGlow(data.player, 'pink');
        this.spawnParticles(data.player, ['💕', '❤️', '💖', '✨'], 8);
        soundManager.playFriendRevealSound();
    }

    // ===== Tier 3 이벤트 =====

    onContractAchieved(data) {
        this.showPopup('✅ 공약 달성!', '#4CAF50');
        this.spawnParticles(null, ['🎉', '✅', '⭐', '🎊'], 15);
        soundManager.playWin();
    }

    onBackrun(data) {
        this.shakeScreen();
        this.showPopup('⚡ 백런!!!', '#FF1744');
        this.spawnParticles(null, ['⚡', '💥', '🔥', '💀'], 20);
        soundManager.playBackrunSound();
    }

    onBigScoreTrick(data) {
        this.showPopup(`💰 ${data.points}점 획득!`, '#FFD700');
        this.spawnParticles(data.player, ['💰', '💎', '🪙'], 8);
        soundManager.playCoinSound();
    }

    // ===== 효과 실행 메서드 =====

    shakeScreen() {
        document.body.classList.add('shake');
        setTimeout(() => document.body.classList.remove('shake'), 400);
    }

    showPopup(text, color) {
        const popup = document.createElement('div');
        popup.className = 'event-popup';
        popup.textContent = text;
        popup.style.color = color;
        document.body.appendChild(popup);
        setTimeout(() => popup.remove(), 1300);
    }

    addGlow(playerIndex, color) {
        const isMobile = document.body.classList.contains('mobile-mode');

        if (isMobile) {
            if (playerIndex === 0) {
                const userTrick = document.getElementById('mobile-user-trick');
                if (userTrick) {
                    userTrick.classList.add(`glow-${color}`);
                    setTimeout(() => userTrick.classList.remove(`glow-${color}`), 2000);
                }
            } else {
                const cell = document.querySelector(`.mobile-ai-cell[data-ai="${playerIndex}"]`);
                if (cell) {
                    cell.classList.add(`glow-${color}`);
                    setTimeout(() => cell.classList.remove(`glow-${color}`), 2000);
                }
            }
        } else {
            const trickCard = document.querySelector(`.trick-card[data-player="${playerIndex}"]`);
            if (trickCard) {
                trickCard.classList.add(`glow-${color}`);
                setTimeout(() => trickCard.classList.remove(`glow-${color}`), 2000);
            }
        }
    }

    addImpact(playerIndex) {
        const isMobile = document.body.classList.contains('mobile-mode');

        if (isMobile) {
            if (playerIndex === 0) {
                const el = document.getElementById('mobile-user-trick');
                if (el) { el.classList.add('impact'); setTimeout(() => el.classList.remove('impact'), 600); }
            } else {
                const cell = document.querySelector(`.mobile-ai-cell[data-ai="${playerIndex}"]`);
                const trickArea = cell?.querySelector('.cell-trick-card');
                if (trickArea) { trickArea.classList.add('impact'); setTimeout(() => trickArea.classList.remove('impact'), 600); }
            }
        } else {
            const el = document.querySelector(`.trick-card[data-player="${playerIndex}"]`);
            if (el) { el.classList.add('impact'); setTimeout(() => el.classList.remove('impact'), 600); }
        }
    }

    addCrack(playerIndex) {
        const isMobile = document.body.classList.contains('mobile-mode');
        if (isMobile) {
            // 모바일에서는 이전 승자의 트릭카드를 어둡게
            if (playerIndex === 0) {
                const el = document.getElementById('mobile-user-trick');
                if (el) { el.style.opacity = '0.4'; setTimeout(() => el.style.opacity = '', 2000); }
            } else {
                const cell = document.querySelector(`.mobile-ai-cell[data-ai="${playerIndex}"]`);
                const trickArea = cell?.querySelector('.cell-trick-card');
                if (trickArea) { trickArea.classList.add('cracked'); setTimeout(() => trickArea.classList.remove('cracked'), 2000); }
            }
        } else {
            const el = document.querySelector(`.trick-card[data-player="${playerIndex}"]`);
            if (el) { el.classList.add('cracked'); setTimeout(() => el.classList.remove('cracked'), 2000); }
        }
    }

    spawnParticles(playerIndex, emojis, count) {
        const container = document.createElement('div');
        container.className = 'particle-container';
        document.body.appendChild(container);

        let cx = window.innerWidth / 2;
        let cy = window.innerHeight / 2;

        if (playerIndex !== null) {
            const isMobile = document.body.classList.contains('mobile-mode');
            let el;
            if (isMobile) {
                el = playerIndex === 0
                    ? document.getElementById('mobile-user-trick')
                    : document.querySelector(`.mobile-ai-cell[data-ai="${playerIndex}"]`);
            } else {
                el = document.querySelector(`.trick-card[data-player="${playerIndex}"]`);
            }
            if (el) {
                const rect = el.getBoundingClientRect();
                cx = rect.left + rect.width / 2;
                cy = rect.top + rect.height / 2;
            }
        }

        for (let i = 0; i < count; i++) {
            const p = document.createElement('div');
            p.className = 'particle';
            p.textContent = emojis[Math.floor(Math.random() * emojis.length)];
            const angle = (Math.PI * 2 * i) / count + (Math.random() - 0.5) * 0.5;
            const dist = 80 + Math.random() * 120;
            const px = Math.cos(angle) * dist;
            const py = Math.sin(angle) * dist - 40;
            const pr = (Math.random() - 0.5) * 720;
            p.style.left = cx + 'px';
            p.style.top = cy + 'px';
            p.style.setProperty('--px', px + 'px');
            p.style.setProperty('--py', py + 'px');
            p.style.setProperty('--pr', pr + 'deg');
            p.style.animationDelay = (Math.random() * 0.2) + 's';
            container.appendChild(p);
        }

        setTimeout(() => container.remove(), 2000);
    }
}

        // ========================================
        // ===== main.js =====
        // ========================================

        class GameController {
            constructor() {
                this.gameState = new GameState();
                this.settings = { ...DEFAULT_SETTINGS };
                this.isMobile = window.innerWidth <= 768;
                if (this.isMobile) {
                    document.body.classList.add('mobile-mode');
                }
                this.ui = new UI(this.gameState, this.settings);
                this.ai = new AI(this.gameState, this.settings);
                this.pendingCard = null;
                this.isProcessing = false;
                this.gameHistory = [];
                this.setupCallbacks();
                this.effectManager = new EffectManager();


                // SoundManager 초기화 (사용자 상호작용 필요하므로 클릭 이벤트 등에서 init 호출 권장되지만 여기서는 우선 생성)
                document.addEventListener('click', () => { soundManager.init(); }, { once: true });

                this.startNewGame();
            }

            setupCallbacks() {
                this.ui.setCallbacks({
                    onBidSubmit: (value, suit) => this.handleBid(value, suit),
                    onBidPass: () => this.handlePass(),
                    onFriendDeclare: (card) => this.handleFriendDeclare(card),
                    onExchangeConfirm: (cards, options) => this.handleExchange(cards, options),
                    onCardSelect: (card) => this.handleCardSelect(card),
                    onJokerSuitSelect: (suit) => this.handleJokerSuit(suit),
                    onNewGame: () => this.startNewGame(),
                    onEndGame: () => this.endSession()
                });
            }

            async startNewGame() {
                this.gameState.reset();
                this.isProcessing = false;
                this.pendingCard = null;
                this.ui.clearTrick();
                this.ui.clearActionButtons();
                this.ui.renderAll();
                await this.delay(500);
                await this.dealCards();
            }

            async dealCards() {
                this.gameState.phase = PHASES.DEALING;
                this.ui.setMessage('카드를 배분하는 중...');
                soundManager.playCardFlip(); // Sound
                const deck = new Deck();
                deck.shuffle();
                this.gameState.floorCards = deck.deal(GAME_CONFIG.FLOOR_CARDS);
                for (let i = 0; i < GAME_CONFIG.PLAYER_COUNT; i++) {
                    const playerIndex = (this.gameState.dealer + 1 + i) % GAME_CONFIG.PLAYER_COUNT;
                    const cards = deck.deal(GAME_CONFIG.CARDS_PER_PLAYER);
                    this.gameState.players[playerIndex].receiveCards(cards);
                    this.gameState.players[playerIndex].sortHand();
                }
                this.ui.renderAll({ animation: 'deal' }); // Pass animation flag
                await this.delay(1500); // Wait for animation
                await this.checkPoolRequest();
            }

            async checkPoolRequest() {
                this.gameState.phase = PHASES.DEAL_CHECK;
                const baseMighty = new Card(SUITS.SPADE, 'A');
                const eligiblePlayers = [];
                for (let i = 0; i < GAME_CONFIG.PLAYER_COUNT; i++) {
                    const hand = this.gameState.players[i].hand;
                    const eligibility = checkPoolRequestEligibility(hand, baseMighty);
                    if (eligibility.eligible) eligiblePlayers.push({ playerIndex: i, eligibility });
                }
                if (eligiblePlayers.length === 0) { await this.startBidding(); return; }

                const userEligible = eligiblePlayers.find(p => p.playerIndex === 0);
                if (userEligible) {
                    this.ui.setMessage(`풀신청 가능! (${userEligible.eligibility.reason})`);
                    this.ui.setActionButtons([
                        { text: '풀신청', primary: true, onClick: () => this.handlePoolRequest(0) },
                        { text: '진행', primary: false, onClick: () => this.continueAfterPoolCheck(eligiblePlayers.filter(p => p.playerIndex !== 0)) }
                    ]);
                } else {
                    await this.processAIPoolRequests(eligiblePlayers);
                }
            }

            async handlePoolRequest(playerIndex) {
                const playerName = playerIndex === 0 ? '당신' : `AI-${playerIndex}`;
                this.ui.setMessage(`${playerName}이(가) 풀신청을 했습니다!`);
                this.ui.clearActionButtons();
                await this.delay(1000);
                await this.askForBid20Accept(playerIndex);
            }

            async processAIPoolRequests(eligiblePlayers) {
                for (const { playerIndex, eligibility } of eligiblePlayers) {
                    if (eligibility.eligible) {
                        this.ui.setMessage(`AI-${playerIndex}이(가) 풀신청을 했습니다! (${eligibility.reason})`);
                        await this.delay(1500);
                        await this.askForBid20Accept(playerIndex);
                        return;
                    }
                }
                await this.startBidding();
            }

            async continueAfterPoolCheck(remaining) {
                this.ui.clearActionButtons();
                if (remaining.length > 0) await this.processAIPoolRequests(remaining);
                else await this.startBidding();
            }

            async askForBid20Accept(poolRequesterIndex) {
                this.gameState.poolRequester = poolRequesterIndex;
                if (poolRequesterIndex !== 0) {
                    this.ui.setMessage('풀신청이 있습니다. 20으로 주공을 하시겠습니까?');
                    this.ui.setActionButtons([
                        { text: '20으로 진행', primary: true, onClick: () => this.acceptBid20(0) },
                        { text: '패스', primary: false, onClick: () => this.checkAIBid20Accept(poolRequesterIndex) }
                    ]);
                } else {
                    await this.checkAIBid20Accept(poolRequesterIndex);
                }
            }

            async checkAIBid20Accept(poolRequesterIndex) {
                this.ui.clearActionButtons();
                for (let i = 1; i < GAME_CONFIG.PLAYER_COUNT; i++) {
                    if (i === poolRequesterIndex) continue;
                    const hand = this.gameState.players[i].hand;
                    if (this.shouldAIAcceptBid20(hand)) {
                        this.ui.setMessage(`AI-${i}이(가) 20으로 진행하겠다고 선언했습니다!`);
                        await this.delay(1500);
                        await this.forceSetMasterWithBid20(i);
                        return;
                    } else {
                        this.ui.setMessage(`AI-${i}: 패스`);
                        await this.delay(800);
                    }
                }
                this.ui.setMessage('아무도 20으로 진행하지 않아 판을 무효로 합니다.');
                await this.delay(2000);
                this.startNewGame();
            }

            acceptBid20(playerIndex) {
                this.ui.clearActionButtons();
                this.ui.setMessage('20으로 주공을 진행합니다!');
                setTimeout(async () => { await this.forceSetMasterWithBid20(playerIndex); }, 1000);
            }

            async forceSetMasterWithBid20(playerIndex) {
                const defaultGiruda = SUITS.SPADE;
                this.gameState.bidding.currentBid = { player: playerIndex, value: 20, suit: defaultGiruda };
                this.gameState.bidding.history.push({ player: playerIndex, value: 20, suit: defaultGiruda, type: 'bid' });
                this.gameState.contract.master = playerIndex;
                this.gameState.contract.bidValue = 20;
                this.gameState.contract.giruda = defaultGiruda;
                this.gameState.contract.isNoGiruda = false;
                this.gameState.contract.mighty = getMighty(defaultGiruda);
                this.gameState.contract.jokerCall = getJokerCall(defaultGiruda);
                this.gameState.players[playerIndex].setRole(ROLES.MASTER);
                const playerName = playerIndex === 0 ? '당신' : `AI-${playerIndex}`;
                this.ui.setMessage(`${playerName}이(가) 20${SUIT_SYMBOLS[defaultGiruda]}로 주공이 되었습니다!`);
                this.ui.renderAll();
                await this.delay(1500);
                await this.endBidding();
            }

            shouldAIAcceptBid20(hand) {
                const baseMighty = new Card(SUITS.SPADE, 'A');
                const hasMighty = hand.some(c => c.equals(baseMighty));
                const hasJoker = hand.some(c => c.isJoker);
                const suitCounts = {};
                for (const suit of Object.values(SUITS)) suitCounts[suit] = hand.filter(c => !c.isJoker && c.suit === suit).length;
                const maxSuitCount = Math.max(...Object.values(suitCounts));
                const highCards = hand.filter(c => !c.isJoker && ['A', 'K', 'Q'].includes(c.rank));
                if (hasMighty && hasJoker && maxSuitCount >= 5) return true;
                if (hasMighty && maxSuitCount >= 6 && highCards.length >= 3) return true;
                if (hasJoker && maxSuitCount >= 6 && highCards.length >= 4) return true;
                return false;
            }

            async startBidding() {
                this.gameState.phase = PHASES.BIDDING;
                this.gameState.currentTurn = this.gameState.getFirstBidder();
                this.ui.renderAll();
                await this.processBidding();
            }

            async processBidding() {
                while (!this.gameState.isBiddingComplete()) {
                    const currentPlayer = this.gameState.currentTurn;
                    const player = this.gameState.players[currentPlayer];
                    this.ui.renderAll();
                    if (player.hasPassed) { this.gameState.currentTurn = this.gameState.getNextPlayer(currentPlayer); continue; }
                    if (player.isHuman) {
                        this.ui.setMessage('비딩하세요');
                        this.ui.showBiddingModal();
                        return;
                    } else {
                        await this.delay(this.settings.aiSpeed);
                        const decision = this.ai.decideBid(currentPlayer);
                        if (decision.action === 'bid') {
                            this.gameState.recordBid(currentPlayer, decision.value, decision.suit);
                            const sym = decision.suit === 'none' ? 'No' : SUIT_SYMBOLS[decision.suit];
                            this.ui.addAILog(currentPlayer, `${decision.value}${sym} 비딩`, decision.reasoning);
                        } else {
                            this.gameState.recordPass(currentPlayer);
                            this.ui.addAILog(currentPlayer, '패스', decision.reasoning);
                        }
                        this.gameState.currentTurn = this.gameState.getNextPlayer(currentPlayer);
                    }
                }
                await this.endBidding();
            }

            handleBid(value, suit) {
                if (this.gameState.isValidBid(value, suit)) {
                    this.gameState.recordBid(0, value, suit);
                    this.gameState.currentTurn = this.gameState.getNextPlayer(0);
                    this.processBidding();
                }
            }

            handlePass() {
                this.gameState.recordPass(0);
                this.gameState.currentTurn = this.gameState.getNextPlayer(0);
                this.processBidding();
            }

            async endBidding() {
                if (this.gameState.bidding.passedPlayers.length === GAME_CONFIG.PLAYER_COUNT) {
                    this.ui.setMessage('전원 패스! 카드를 다시 배분합니다...');
                    await this.delay(2000);
                    this.startNewGame();
                    return;
                }
                if (!this.gameState.setupContract()) {
                    this.ui.setMessage('오류가 발생했습니다.');
                    return;
                }
                const master = this.gameState.contract.master;
                const bidValue = this.gameState.contract.bidValue;
                const giruda = this.gameState.contract.giruda;
                const girudaSymbol = this.gameState.contract.isNoGiruda ? 'No' : (giruda ? SUIT_SYMBOLS[giruda] : '-');
                this.ui.setMessage(`${this.gameState.players[master].name}이(가) ${bidValue}${girudaSymbol}로 주공!`);
                this.ui.renderAll();
                await this.delay(1500);
                await this.startExchange();
            }

            async startExchange() {
                this.gameState.phase = PHASES.EXCHANGING;
                const master = this.gameState.contract.master;
                const masterPlayer = this.gameState.players[master];
                masterPlayer.receiveCards(this.gameState.floorCards);
                masterPlayer.sortHand(this.gameState.contract.giruda, this.gameState.contract.mighty);
                this.ui.renderAll();
                if (masterPlayer.isHuman) {
                    this.ui.setMessage('버릴 카드 3장을 선택하세요');
                    this.ui.showExchangeModal();
                } else {
                    await this.delay(this.settings.aiSpeed);
                    const decision = this.ai.selectCardsToDiscard(master);
                    this.ui.addAILog(master, '카드 교환', decision.reasoning);
                    this.performExchange(master, decision.cards, { newGiruda: decision.newGiruda, isNoGiruda: decision.isNoGiruda, isSolino: decision.isSolino });
                }
            }

            handleExchange(cards, options = {}) { this.performExchange(0, cards, options); }

            performExchange(playerIndex, cards, options = {}) {
                const player = this.gameState.players[playerIndex];
                const currentBid = this.gameState.contract.bidValue;
                const isMaxBid = currentBid >= GAME_CONFIG.MAX_BID;

                let newGiruda = options.newGiruda || null;
                let isNoGiruda = options.isNoGiruda || false;
                let isSolino = options.isSolino || false;

                const messages = [];

                if (isNoGiruda && isMaxBid) {
                    this.gameState.contract.giruda = null;
                    this.gameState.contract.isNoGiruda = true;
                    this.gameState.contract.mighty = new Card(SUITS.SPADE, 'A');
                    this.gameState.contract.jokerCall = getJokerCall(null);
                    messages.push('노기루다 선언!');
                } else if (newGiruda && newGiruda !== this.gameState.contract.giruda) {
                    const oldGiruda = this.gameState.contract.giruda;
                    const newBid = isMaxBid ? currentBid : Math.min(currentBid + 2, GAME_CONFIG.MAX_BID);
                    this.gameState.contract.giruda = newGiruda;
                    this.gameState.contract.bidValue = newBid;
                    this.gameState.contract.isNoGiruda = false;
                    this.gameState.contract.mighty = getMighty(newGiruda);
                    this.gameState.contract.jokerCall = getJokerCall(newGiruda);
                    const oldName = oldGiruda ? SUIT_NAMES[oldGiruda] : '노기루다';
                    if (isMaxBid) messages.push(`기루다 변경: ${oldName} → ${SUIT_NAMES[newGiruda]}`);
                    else messages.push(`기루다 변경: ${oldName} → ${SUIT_NAMES[newGiruda]} (공약 → ${newBid})`);
                }

                if (isSolino && isMaxBid) {
                    this.gameState.contract.isSolino = true;
                    messages.push('노프렌드(솔리노) 선언!');
                }

                if (messages.length > 0) this.ui.setMessage(messages.join(' / '));

                for (const card of cards) player.playCard(card);
                this.gameState.floorCards = cards;
                const floorPoints = cards.filter(c => c.isPointCard());
                if (floorPoints.length > 0) {
                    this.gameState.players[this.gameState.contract.master].addScoreCards(floorPoints);
                }

                player.sortHand(this.gameState.contract.giruda, this.gameState.contract.mighty);
                this.ui.renderAll();
                this.startFriendDeclaration();
            }

            async startFriendDeclaration() {
                this.gameState.phase = PHASES.FRIEND_DECLARATION;
                const master = this.gameState.contract.master;
                const masterPlayer = this.gameState.players[master];

                if (this.gameState.contract.isSolino) {
                    this.ui.setMessage('노프렌드(솔리노)로 진행합니다!');
                    this.gameState.setFriend(null);
                    this.ui.renderAll();
                    await this.delay(1500);
                    this.startPlaying();
                    return;
                }

                if (masterPlayer.isHuman) {
                    this.ui.setMessage('친구 카드를 선언하세요');
                    this.ui.showFriendModal();
                } else {
                    await this.delay(this.settings.aiSpeed);
                    const decision = this.ai.selectFriendCard(master);
                    this.ui.addAILog(master, decision.isNoFriend ? '노프렌드 선언' : `친구: ${decision.card.toString()}`, decision.reasoning);
                    this.gameState.setFriend(decision.isNoFriend ? null : decision.card);
                    this.ui.renderAll();
                    await this.delay(1000);
                    this.startPlaying();
                }
            }

            handleFriendDeclare(card) {
                this.gameState.setFriend(card);
                this.ui.renderAll();
                setTimeout(() => this.startPlaying(), 500);
            }

            async startPlaying() {
                this.gameState.phase = PHASES.PLAYING;
                this.gameState.round = 1;
                this.isProcessing = false;
                soundManager.playTurnStart(); // Sound

                if (this.settings.useSayeon && this.shouldAskSayeon()) {
                    await this.askSayeon();
                    return;
                }

                this.gameState.startTrick(this.gameState.contract.master);
                this.ui.renderAll();
                await this.processTrick();
            }

            shouldAskSayeon() {
                const contract = this.gameState.contract;
                const masterIndex = contract.master;
                const masterHand = this.gameState.players[masterIndex].hand;
                if (contract.isNoFriend || contract.isSolino) return false;
                if (contract.friendCard && contract.friendCard.isJoker) return false;
                if (masterHand.some(c => c.isJoker)) return false;
                if (contract.friend === null && !contract.friendCard) return false;
                return true;
            }

            async askSayeon() {
                const masterIndex = this.gameState.contract.master;
                const masterPlayer = this.gameState.players[masterIndex];
                let actualFriendIndex = this.gameState.contract.friend;
                if (actualFriendIndex === null || actualFriendIndex === undefined) {
                    const friendCard = this.gameState.contract.friendCard;
                    for (let i = 0; i < GAME_CONFIG.PLAYER_COUNT; i++) {
                        if (i === masterIndex) continue;
                        if (this.gameState.players[i].hasCard(friendCard)) { actualFriendIndex = i; break; }
                    }
                }
                if (actualFriendIndex === null || actualFriendIndex === undefined) {
                    this.gameState.startTrick(masterIndex);
                    this.ui.renderAll();
                    await this.processTrick();
                    return;
                }
                const friendPlayer = this.gameState.players[actualFriendIndex];
                const friendHasJoker = friendPlayer.hand.some(c => c.isJoker);

                if (masterPlayer.isHuman) {
                    this.ui.setMessage('주공: "사연?"');
                    this.ui.setActionButtons([
                        { text: '사연 묻기', primary: true, onClick: () => this.processSayeonResponse(actualFriendIndex, friendHasJoker) },
                        { text: '건너뛰기', primary: false, onClick: () => this.skipSayeon() }
                    ]);
                } else {
                    this.ui.setMessage(`AI-${masterIndex}: "사연?"`);
                    await this.delay(1000);
                    await this.processSayeonResponse(actualFriendIndex, friendHasJoker);
                }
            }

            async processSayeonResponse(friendIndex, friendHasJoker) {
                this.ui.clearActionButtons();
                const friendPlayer = this.gameState.players[friendIndex];
                const response = friendHasJoker ? '넌사' : '사연';

                if (friendPlayer.isHuman) {
                    this.ui.setMessage(`당신은 친구입니다. 조커를 ${friendHasJoker ? '가지고 있습니다' : '가지고 있지 않습니다'}.`);
                    this.ui.setActionButtons([
                        { text: friendHasJoker ? '넌사 (조커 있음)' : '사연 (조커 없음)', primary: true, onClick: () => this.completeSayeon(response) }
                    ]);
                } else {
                    this.ui.setMessage(`친구의 응답: "${response}"`);
                    this.gameState.sayeonResponse = response;
                    await this.delay(1500);
                    this.completeSayeon(response);
                }
            }

            completeSayeon(response) {
                this.ui.clearActionButtons();
                this.gameState.sayeonResponse = response;
                const masterIndex = this.gameState.contract.master;
                if (response === '넌사') this.ui.setMessage('친구가 조커를 보유하고 있습니다.');
                else this.ui.setMessage('친구가 조커를 보유하고 있지 않습니다.');
                setTimeout(() => {
                    this.gameState.startTrick(masterIndex);
                    this.ui.renderAll();
                    this.processTrick();
                }, 1500);
            }

            skipSayeon() {
                this.ui.clearActionButtons();
                this.gameState.sayeonResponse = null;
                const masterIndex = this.gameState.contract.master;
                this.gameState.startTrick(masterIndex);
                this.ui.renderAll();
                this.processTrick();
            }

            async processTrick() {
                if (this.gameState.trick.cards.length >= GAME_CONFIG.PLAYER_COUNT) {
                    await this.endTrick();
                    return;
                }
                let safetyCounter = 0;
                while (this.gameState.trick.cards.length < GAME_CONFIG.PLAYER_COUNT) {
                    safetyCounter++;
                    if (safetyCounter > 20) {
                        console.error('processTrick 무한루프 감지, 강제 종료');
                        this.ui.setMessage('오류가 발생했습니다. 새 게임을 시작합니다.');
                        await this.delay(2000);
                        this.startNewGame();
                        return;
                    }
                    const currentPlayer = this.gameState.currentTurn;
                    const player = this.gameState.players[currentPlayer];
                    this.ui.renderAll();
                    if (player.isHuman) {
                        this.ui.setMessage('카드를 선택하세요');
                        this.isProcessing = false;
                        return;
                    } else {
                        await this.delay(this.settings.aiSpeed);
                        const alreadyPlayed = this.gameState.trick.cards.some(p => p.player === currentPlayer);
                        if (alreadyPlayed) continue;
                        let decision;
                        try {
                            decision = this.ai.selectCardToPlay(currentPlayer);
                        } catch (e) {
                            console.error(`AI ${currentPlayer} 에러:`, e);
                        }
                        if (!decision || !decision.card) {
                            console.error(`AI ${currentPlayer} failed, 강제 카드 선택`);
                            const fallbackCard = player.hand[0];
                            if (fallbackCard) {
                                decision = { card: fallbackCard, jokerCallSuit: null, reasoning: ['에러 복구 - 강제 선택'] };
                            } else {
                                continue;
                            }
                        }

                        const card = player.playCard(decision.card);
                        if (card) {
                            soundManager.playCardPlay(); // Sound
                            this.gameState.playCardToTrick(currentPlayer, card, decision.jokerCallSuit);
                            this.ui.addAILog(currentPlayer, `${card.toString()} 출전`, decision.reasoning);
                            this.ui.renderAll();
                            this.ui.renderTrick();
                        }
                    }
                }
                await this.endTrick();
            }

            handleCardSelect(card) {
                if (this.isProcessing) return;
                if (this.gameState.currentTurn !== 0) return;
                if (this.gameState.trick.cards.some(p => p.player === 0)) return;
                const player = this.gameState.players[0];
                const mightyPlayedInTrick = this.gameState.trick.cards.some(p => p.card.equals(this.gameState.contract.mighty));
                const isFirstRoundLead = (this.gameState.round === 1
                    && this.gameState.trick.cards.length === 0
                    && 0 === this.gameState.contract.master);

                const playableCards = getPlayableCards(player.hand, this.gameState.trick.leadSuit, this.gameState.round, {
                    mighty: this.gameState.contract.mighty,
                    jokerCalled: this.gameState.trick.jokerCalled,
                    mightyPlayedInTrick,
                    isFirstRoundLead,
                    giruda: this.gameState.contract.giruda
                });

                if (!playableCards.some(c => c.equals(card))) {
                    soundManager.playError(); // Sound
                    return;
                }
                if (this.gameState.trick.cards.length === 0 && card.isJoker && this.gameState.round >= 2 && this.gameState.round <= 9) {
                    this.pendingCard = card;
                    this.ui.showJokerCallModal();
                    return;
                }
                this.playUserCard(card, null);
            }

            handleJokerSuit(suit) {
                if (this.pendingCard) { this.playUserCard(this.pendingCard, suit); this.pendingCard = null; }
            }

            async playUserCard(card, jokerCallSuit) {
                if (this.isProcessing) return;
                const player = this.gameState.players[0];
                const playedCard = player.playCard(card);
                if (playedCard) {
                    soundManager.playCardPlay(); // Sound
                    this.isProcessing = true;
                    this.gameState.playCardToTrick(0, playedCard, jokerCallSuit);
                    this.ui.renderAll();
                    this.ui.renderTrick();
                    await this.processTrick();
                    this.isProcessing = false;
                }
            }

            async endTrick() {
                this.isProcessing = true;
                this.gameState.phase = PHASES.TRICK_END;
                const { winner, winningCard } = this.gameState.determineTrickWinner();
                this.ui.renderTrick();
                this.ui.setMessage(`${this.gameState.players[winner].name}이(가) ${winningCard.toString()}(으)로 승리!`);
                await this.delay(2000);
                this.gameState.endTrick();
                // endTrick() 안, this.gameState.endTrick() 다음 줄에 추가

                // ★ Tier 3 이벤트 체크
                const trickPoints = this.gameState.players[winner].scoreCards.length;
                const prevGovScore = this.gameState.governmentScore;

                // 대량 점수 트릭 (이번 트릭에서 3점 이상)
                const thisRoundPoints = this.gameState.trick.cards
                    ? this.gameState.trick.cards.reduce((s, p) => s + (p.card && p.card.isPointCard() ? 1 : 0), 0)
                    : 0;
                // trick.cards는 이미 endTrick에서 처리되었으므로, 점수는 승자의 scoreCards 변화로 판단
                // 간접적으로 판단: endTrick 전후의 governmentScore 차이
                this.gameState.updateTeamScores();
                const newGovScore = this.gameState.governmentScore;

                // 공약 달성 순간
                const bidValue = this.gameState.contract.bidValue;
                if (prevGovScore < bidValue && newGovScore >= bidValue) {
                    eventBus.emit('contract-achieved', { score: newGovScore, bidValue });
                }

                this.ui.renderAll();

                if (this.gameState.round >= GAME_CONFIG.TOTAL_ROUNDS) {
                    this.isProcessing = false;
                    await this.endGame();
                } else {
                    soundManager.playTurnStart(); // Sound
                    this.gameState.round++;
                    this.gameState.phase = PHASES.PLAYING;
                    this.gameState.startTrick(winner);
                    this.ui.clearTrick();
                    this.ui.renderAll();
                    await this.delay(500);
                    this.isProcessing = false;
                    await this.processTrick();
                }
            }

            async endGame() {
                this.gameState.phase = PHASES.GAME_END;
                const result = this.gameState.calculateFinalScores();
                for (const r of result.results) this.gameState.players[r.player].totalScore += r.change;

                this.gameHistory.push({
                    gameNumber: this.gameHistory.length + 1,
                    winner: result.winner, isBackrun: result.isBackrun,
                    bidValue: this.gameState.contract.bidValue,
                    governmentScore: this.gameState.governmentScore,
                    master: this.gameState.contract.master,
                    friend: this.gameState.contract.friend,
                    giruda: this.gameState.contract.giruda,
                    results: result.results.map(r => ({ player: r.player, change: r.change })),
                    cumulativeScores: this.gameState.players.map(p => p.totalScore)
                });

                this.ui.renderAll();

                const userWon = result.results.find(r => r.player === 0).change > 0;
                if (userWon) soundManager.playWin(); // Sound

                this.ui.showResultModal(result, this.gameHistory);
            }

            endSession() {
                this.ui.hideResultModal();
                document.getElementById('info-bar').style.display = 'none';
                document.getElementById('game-area').style.display = 'none';
                document.getElementById('action-area').style.display = 'none';
                document.getElementById('mobile-ai-grid').style.display = 'none';
                document.getElementById('mobile-center-area').style.display = 'none';
                const logPanel = document.getElementById('ai-log-panel');
                if (logPanel) logPanel.style.display = 'none';
                const modalOverlay = document.getElementById('modal-overlay');
                if (modalOverlay) modalOverlay.classList.add('hidden');
                this.showFinalSummary();
            }

showFinalSummary() {
    let finalScores = [0, 0, 0, 0, 0];
    const playerNames = this.gameState.players.map(p => p.name);
    if (this.gameHistory.length > 0) {
        finalScores = this.gameHistory[this.gameHistory.length - 1].cumulativeScores || finalScores;
    }

    let winnerIndex = 0;
    let maxScore = finalScores[0] || 0;
    for (let i = 1; i < finalScores.length; i++) {
        if ((finalScores[i] || 0) > maxScore) {
            maxScore = finalScores[i] || 0;
            winnerIndex = i;
        }
    }

    const overlay = document.getElementById('final-summary-overlay');

    let html = '<div class="final-summary-content">';
    html += '<h2>🎴 게임 종료</h2>';

    if (this.gameHistory.length > 0) {
        html += `<div class="fs-subtitle">총 ${this.gameHistory.length}게임 — 최종 누적 점수</div>`;

        for (let i = 0; i < playerNames.length; i++) {
            const score = finalScores[i] || 0;
            const isWinner = i === winnerIndex;
            const scoreClass = score >= 0 ? 'positive' : 'negative';
            const scoreText = score >= 0 ? `+${score}` : `${score}`;
            const crown = isWinner ? '👑 ' : '';
            const rowClass = isWinner ? 'fs-player-row winner' : 'fs-player-row';

            html += `<div class="${rowClass}">`;
            html += `<span class="fs-player-name">${crown}${playerNames[i]}</span>`;
            html += `<span class="fs-score ${scoreClass}">${scoreText}점</span>`;
            html += `</div>`;
        }

        const isHumanWinner = winnerIndex === 0;
        if (isHumanWinner) {
            html += `<div style="text-align:center;color:#FFD700;font-size:14px;margin-top:12px;">🏆 축하합니다! 우승!</div>`;
        } else {
            html += `<div style="text-align:center;color:#aaa;font-size:13px;margin-top:12px;">${playerNames[winnerIndex]} 우승</div>`;
        }
    } else {
        html += '<div class="fs-subtitle">진행된 게임이 없습니다.</div>';
    }

    html += '<button class="fs-reload-btn" onclick="location.reload()">새로 시작</button>';
    html += '<div class="fs-footer">페이지를 새로고침하여 새 게임을 시작합니다</div>';
    html += '</div>';

    overlay.innerHTML = html;
    overlay.classList.remove('hidden');

    // 게임 상태 초기화
    this.gameState.reset();
    for (const player of this.gameState.players) player.totalScore = 0;
    this.isProcessing = false;
    this.pendingCard = null;
    this.gameHistory = [];
}


            delay(ms) { return new Promise(resolve => setTimeout(resolve, ms)); }
        }

        // ===== 게임 시작 =====
        document.addEventListener('DOMContentLoaded', () => {
            window.game = new GameController();
        });
    </script>
</body>

</html>